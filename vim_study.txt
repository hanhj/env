第一章 帮助
	:help key	(h)	显示帮助。如果带key，则显示key的帮助。
	:options	显示选项帮助
	在vim中执行shell命令需要在命令前加上惊叹号
	:!command
	$VIM		vim的路径
	$VIMRUNTIME	vim的运行路径,比如我的机子是/usr/share/vim/vim73
	:scriptnames	显示脚本文件
	%	跳转到匹配的(){}[]处。在编程的时候比较快捷。

第二章 移动
	1) 关于vim的状态：
		刚进入vim的时候，vim处于普通(normal)状态，此时只能用键盘上的上下左右或特殊键的组合来移动光标。不能编辑文本。
		在normal状态下，键入i,a,o或I,A,O键，vim将进入编辑（edit) 状态，此时可以键入字符。在edit状态按ESC键，将退出edit状态，恢复到normal状态。
		在normal状态下，键入:vim将进入命令(command)状态。此时光标位于最下一行，并有提示符:。此时可以输入命令。在命令状态中按ESC键，将退出command状态，恢复到normal状态。
		在normal状态下，键入Q将进入Ex模式。此时键入visual回到normal状态。
		在以下的描述中如果英文单词前面有:表示是在命令状态下。比如:set,表示在命令状态下输入set命令,否则为normal状态。
 		如果名词后面带一个括号，则括号中的字符作为前面名词的缩略。比如number(nu),表示可以用nu来代替number。
		如果有xx->xxx，表示助记符，将xx理解成xxx。
	2) 一般的移动
		在normal状态下
		h	左移
		l	右移
		j	下移
		k	上移
		w	向后移动到下一个单词的首位置	w->next word
		b	向前移动到前一个单词的首位置	b->back word
		e	向后移动到下一个单词的尾位置	e->end
			如果是W,B,E大写字母则认为单词是以空格,)等作为分隔。这样移动将更快。
		ge	向前移动到前一个单词的尾位置	g->go
		以上字母前面都可以加上数字，以代表移动多少数量。比如：
		3k	表示上移3行。

		gg	:跳转到开始
		G	：跳转到结尾
		xgg	:跳转到x行
		xG	:跳到x行
		0	:跳转到本行开始
		$	:跳转到本行的结束。
		fx	:跳转到字符x处,x是任意字符	f->find
		Fx	:向左跳转到字符x处

		记住常用的跳转命令：j,l,h,k,g
		
		ctrl-f	向前翻页	f->foward
		ctrl-b	向后翻页	b->backward
		zt	将当前光标所在位置提到屏幕顶行	z想象成一个折叠的纸，t->top
		zb	将当前光标所在位置移到屏幕底行。b->bottom
		zz	将当前光标所在位置移到屏幕中央。
		ctrl-]	将以光标所在处的单词为关键字，跳转到其相关联的地方（称为tag标记) 
		ctrl-o或ctrl-t从跳转处返回。
		:xx	直接跳转到xx行
		:set number(nu)		显示行号
		:set nonumber(nonu)	不显示行号
	3) 用标记跳转：
		mx	：设置标记。在noraml状态下。x是任意小写字母。
		`x	：跳转到标记x处。在noraml状态下。`是键盘左上角的反引号,x是刚才所做的标记字母。
			比如将光标移动到某行，在noraml状态下键入ma,然后转到其他地方，再敲入`a则可以跳回到刚才做标记的地方。
		注意用小写字母是在本文档中设置标记，离开本文档该标记就消失。如果用大写字母做标记，则是全局的,可以在多个文件中跳转。
		做标记也可用%，比如在文档的%50处做标记，可以在normal模式下输入50%ms。
		几个特殊标记：
		 	`表示上次跳转的地方，``就可以在两次跳转之间来回跳了。
			.表示最后修改的地方.
			"表示上次编辑该文件，最后光标停留的地方。
			[表示最后修改开始的位置。
			]表示最后修改结束的位置。
		:marks	显示标记
	4) 搜索字符串
		/str 搜索str，如果找到，会将str反显。此时按n将跳转到下一个，shift-n跳转的前一个。
			/str实际上是字符串匹配，可以用正则表达式中的符号。
			关于正则表达式，可以参见正则表达式的相关描述（:h
			pattern)，使用方法同其他程序中的方法是一样的。这里提几个vim中常用的转义符：
			\s	whitespace character: <Space> and <Tab>		
			\S	non-whitespace character; opposite of \s	
			\d	digit:				[0-9]		
			\D	non-digit:			[^0-9]		
			\x	hex digit:			[0-9A-Fa-f]	
			\X	non-hex digit:			[^0-9A-Fa-f]	
			\o	octal digit:			[0-7]		
			\O	non-octal digit:		[^0-7]		
			\w	word character:			[0-9A-Za-z_]	
			\W	non-word character:		[^0-9A-Za-z_]	
			\h	head of word character:		[A-Za-z_]	
			\H	non-head of word character:	[^A-Za-z_]	
			\a	alphabetic character:		[A-Za-z]	
			\A	non-alphabetic character:	[^A-Za-z]	
			\l	lowercase character:		[a-z]		
			\L	non-lowercase character:	[^a-z]		
			\u	uppercase character:		[A-Z]		
			\U	non-uppercase character:	[^A-Z]		
			\e	matches <Esc>					
			\t	matches <Tab>					
			\r	matches <CR>					
			\b	matches <BS>					
			\n	matches an end-of-line				
			注意：这里是vim的转义符，不同的程序转义符并不一样。比如在grep中\d就没有定义。
		:set ignorecase		(ic)	搜索时忽略大小写，这是默认的。
		:set noignorecase	(noic)	不忽略大小写，即大小写敏感。
		如果不想输入太多的字符，可以将光标定位到某个单词，然后输入*，
		此时vim会自动提取光标所在处的单词向后进行搜索。输入#，将向前跳转。
		:set incsearch		(is)	可以在输入查找字符串的时候就开始匹配。
		:set noincsearch	(nois)	可以取消上面设置。
		:set wrapscan		(ws)	搜索时回转
		:set nowrapscan		(nows)	取消搜索回转
		
第三章 文本编辑
	1) 基本命令
		a	进入编辑模式，并将光标向后移动1位
		A	进入编辑模式，并将光标移动到行尾	
		i	进入编辑模式，光标不移动。
		I	进入编辑模式，并将光标移动到行首（第一个字符）
		o	进入编辑模式，在当前行后插入一行。
		O	进入编辑模式，在当前行前插入一行。
		r	替换当前光标下的字符,光标不移动，替换后还是normal状态。
		R	进入替换模式，键入的字符替换原字符，光标向后移动。
		d{motion}	删除motion移动到的字符。
			motion是移动单词，比如w:next word,b:back word,l,h,j,k等。
			比如：
			dw	删除后一个单词
			db	删除前一个单词
			dj	删除下一行
			d4j	删除下面4行
			dk	删除上一行
			关于motion的详细解释见附录。

		dfx	删除从当前光标到所找到的第一个字符x之间的字符，包括x。比如dfa，表示删除从当前光标到第一个字母a之间的内容。
			dFx：向前删除
		d$	删除当前光标到行尾的字符。$表示行尾。
		D	删除从当前光标行尾的字符。同d$
		dd	删除一行
		x	删除当前光标下的字符。相当于dl	l表示右移
		X	删除当前光标左边的字符。相当于dh	h表示左移
		c	与d类似，但是删除后将进入插入模式
		cl	与dl类似，但是删除后将进入插入模式。快捷键是s
		cc	与dd类似，并进入插入模式。快键键是S
		y{motion}	根据motion复制内容	y->yank 拉
			比如：
			yw	:复制当前光标到下一个单词的内容	
			yb	：复制当前光标到前一个单词的内容
			yj	：复制当前行到下一行的内容
			yk	：复制当前行到前一行的内容
		yy	复制一行	
		Y	复制多行，同yy
		p	粘贴内容到当前光标后
		P	粘贴内容到当前光标前
		以上命令前都可以加上数字以表示重复次数。比如3dd表示删除从当前行删除3行。
		记住常用的编辑命令：a,i,o,d,y,x,p

		visual模式：可视化模式。有三种visual模式。
		V	进入行visual模式。行visual模式是以整行作为处理单位。
		v	进入visual模式。visual模式与行visual模式所不同的是开始位置从第一个单词开始。
		ctrl-v进入列块的visual模式

		visual模式下，先用光标选择块，然后：
			I	insert，在选择的块插入后面敲入的字符
			c	change，删除选择的块，然后进入编辑模式,用敲入的字符代替块。
			C	删除块到行尾的字符，后面同c
			r	replace,将块用一个字符来替换。
			>	右移块
			<	左移块
			J	将块中的内容连接成一行
		
		:[pos] read(r) file	:在pos处下一行，插入文件。没有pos默认是当前位置。
		:[range] write(w) file	:将range范围内的内容写入文件。

第四章 定制vim	
	1) 使用vim自带选项。
		vim的选项很多，通过定制可以更方便的使用vim.
		我们可以手动定制vim的一些选项，比如 
		:set(se) number(nu)	显示行号 
		:se list		显示控制字符
		:se filetype	显示当前文件的文件类型。
		:filetype on	打开文件类型自动检测
			文件类型检测是用$VIMRUNTIME/filetype.vim中来检测，用:filetype 可以显示当前文件自动检测的情况。
		vi中的选项可以是：
			布尔型变量：可以用:set xx 来打开，:set noxx来关闭。比如：
				:se nu		打开行号显示
				:se nonu	关闭行号显示
			参数型选项：
				:se xx=xxx	设置xx选项为xxx
				:se xx?		显示当前值
				:se xx		显示当前值
				:se xx&		恢复xx为默认值
		:se		查看当前的选项情况
			关于选项这里不用赘述，具体配置项可以参见options(用:options)

		.	重复命令：
			在vim中会记录所敲入的任何命令，在normal状态下，键入.可以执行最后一次所执行的命令。
	2) 添加一个plugin。
		vim支持插件，以增强vim的功能。（用:scriptnames(scr)可以显示当前装入的脚本文件) 
		vim的安装目录一般在 /usr/share/vim/vimxx(xx是当前vim的版本号)。在vim中vim的安装位置保存在$VIMRUNTIME变量中。在此目录下面有:
		/macros		:定义了全局配置；
		/ftplugin	:定义不同文件类型的插件。
		将macros或ftplugin目录下需要的文件，拷贝到~/.vim/plugin目录下。就可以支持这些插件了。插件的文件名后缀一般是vim
		将上述目录中的相关插件的txt文件拷贝到~/.vim/doc目录下，然后再vim中执行:helptags ~/.vim/doc就可以在帮助文件里支持这些插件了。
	3) 关于颜色
		:syntax	enable可以打开语法高亮。
		:colorscheme (colo)	设置配色方案
			配色方案在 /usr/share/vim/vimxx/colors/目录下 

第五章 多文件编辑：
	1) 打开多文件:
		方法1:在控制台时,输入多个文件名。
			如：vim a b c
		方法2：在命令模式中输入:edit(e) 文件名。
			:vim e a 读入文件a
			:e!	丢弃当前文件修改，重新读入文件。利用这一点，可以在当当前文件别其他程序修改后，重新读入文件。
		方法3：在命令模式中输入：args 文件名。相当于启动vim 给其多个参数。
		:args a b c
	2) 切换文件：
		:next(n)	切换到下一个文件
		:previous(prev)	切换到前一个文件
		ctrl-^	在当前文件与执行了切换动作的两个文件之间来回切换。
	3) 保存文件：
		:w	:保存当前缓冲区到进入时打开的文件。
		:w filename ：保存当前缓冲区到文件filename中。缓冲区没变，即当前缓冲区针对的还是原来打开的文件，
		如果修改了没有保存，缓冲区的标志仍然是没有保存。此时在vim状态栏中所指示的文件名依然是原来的文件。
		:saveas (sav) filename:文件改名并保存。将当前缓冲区名改为filename，并保存。
		% 代表当前编辑的文件。
	4) 移动到窗口：
		将光标移动到窗口
		ctrl-w  h	左边
		ctrl-w	j	下边
		ctrl-w	k	上边
		ctrl-w	l	右边
	5) 窗口移动
		将当前窗口移动到
		ctrl-w  H	左边
		ctrl-w	J	下边
		ctrl-w	K	上边
		ctrl-w	L	右边
		:files	在状态栏中显示当前编辑的文件
	6) 关于全部窗口的操作：
		:wall(wa)	保存所有窗口中文件
		:qall(qa)	退出所有窗口
	7) 比较两个文件
		vimdiff a b	在bash环境中
		在进入vim后
		:diffsplit(diffs) file :前面可以加上vertical(vert) 表示垂直
		:diffpatch(diffp) patchfile :对当前文件打上patch

第六章 分隔窗口
	1) 基本命令
		:split(sp)[file]	水平建立一个窗口。
		如果不带file，则将当前文件分隔成水平两个部分。
		如果带file，则在新窗口打开文件file
		:vsplit(vsp)[file] 垂直分隔
		:new[file]	水平开一个新窗口，并建立一个新文件缓冲区。
		:vnew[file]	垂直开一个新窗口，并建立一个新文件缓冲区。
		:close(clo)	关闭当前窗口
		:only(on)	关闭除当前窗口的其他窗口。 

第七章 大刀阔斧
	本章介绍一些影响范围较大的命令
	1) 宏命令
		与word中将操作动作记录下来，以后可以调用这些动作序列功能类似，在vim中也有类似的动作记录。
		qx	:启动宏记录。在normal状态下敲入q然后再敲入一个字母，就启动了一个动作序列记录。x为小写字母a-z，表示该宏的名字。
			然后就像正常编辑一样进行操作，最后敲入q退出宏记录状态。
		@x	:执行宏。在想要执行宏的行，在normal状态下输入@x将执行此宏。@@表示重复执行前一次所执行的宏（不能用.）。
		"xp	:显示宏。在任意空白行，在normal状态下输入"xp，x是宏名。
			命令的解释："表示对寄存器操作，x是要操作的宏，p是paste。
			实际上宏命令与d，y操作一样，也是将内容保存到一个寄存器中。
			这里有必要再对我们熟悉的d，y操作进一步学习。
			实际上d，y操作的前面除了可以加上数字以表示重复外，还有一个["x]选项，意思是将d或y的内容保存到某个有名字的寄存器中。
			所以，完整的d或y操作命令应当是:["x]y{motion},表示根据motion将内容复制到寄存器x中。比如：
			"ayy	表示复制当前行内容到a寄存器中。只不过平时为了方便，我们不加上前面的寄存器选项，此时vim将内容保存到默认的寄存器中。
		"xy$:修改宏。如果所记录的宏不正确，又不想重新输一遍，则可以在上面所显示的宏中进行修改，然后退出到noraml状态下，用此命令进行保存。
		:register(reg) 显示寄存器内容
		例子：想将以下代码中的return 0;用外部文件a来替换。
			fun1(){
				return 0;
			}
			fun2(){
				return 0;
			}
			fun3(){
				return 0;
			}
			a文件中的内容为：
				int len=0;
				int offset=0;
				len=sizeof(p);
			在normal状态下输入qa，然后键入以下内容：
			^jddk:read ajjjkI				4j^
			输入完用q结束。
			上面的一些控制字符是在命令输入时产生的。
			然后将光标放到第一行，执行3@a,就可以了。
	2) 替换
		:[range]substitute(s)/from/to/[flags]
			在指定范围内用to字串替换from字串。
			from一般是正则表达式。
			range 范围:
				可以用数字，特殊字符，或正则表达式
				数字：
					a,b	起始a，终点b
					没有指定a，b则是当前行
				特殊字符：
					$	最后一行
					%	全文
				标记：
					`a,`b
				正则表达式：
					/expr1/,/expr2/
			from:匹配字串
				可以用正则表达式 
				在正则表达式中的命令分隔符可以改变。（通常是为了显示明了）
				比如在正文中搜索fun1,到fun2之间的，将return 0 替换成return 1
				/fun1/,/fun2/s=return 0=return 1=
	3) 全局命令
		:[range]global(g)/pattern/command/flag
			与substitute命令所不同的是后面可以是命令。
			需要注意的是命令是在命令模式下输入的命令，而不是normal状态下的命令。
	4）visual mode模式
		visual mode模式可以通过光标来选择一块区域。
		v	进入visual mode
		V	进入行visual mode
		CTRL-V	进入块visual mode 
		多重复制
				在visual模式下，可以将多个地方的内容合在一起进行复制：
				先进入visual模式，然后选择文本，"xy x是任意小写字母，此时vim提示复制了几行内容,并退出visual模式。
				然后到另外一处用visual模式选择文本，此时用"Xy进行复制，X是刚才字母的大写字母。此时在x寄存器中就追加了刚才复制的文本。然后用p就可以黏贴了。
				实际上在vim中的寄存器用大写，表示追加。
	5）格式化文本
		:se textwidth=xx	设置每行的列数
		gqap	:gq表示整理文本，ap表示一段文本
	6) 改变大小写
		gu{motion}	小写	例如guw
		gU{motion}	大写
		g~{motion}	大小写反转	g~~
		gUU			整行全部大写
		guu			整行全部小写
	7) 外部程序
		[range]!command	:
			range是执行范围
			!表示要执行外部程序，
			command是外部程序。
			例如，将当前行下三行排序。执行如下命令：
			在normal状态执行：!3j,此时命令行会出现:.,.+3!,输入sort就可以了。		
			在visual模式下，也可以执行。先选定范围，再输入!,此时vim会自动添加range部分,然后输入sort命令。
	8） 部分写入文件
		:[range]w file 
		:[range]w >>file	追加

第八章 交换文件
	为了防止文件丢失，vim会每4秒不连续键入，或敲入200个字符后同步磁盘。
	:se updatetime?
	:se updatecount?来查看
	一旦发生错误，可以通过交换文件来恢复文本。
	vim -r file		:shell下，-r 表示恢复
	vim -r			:查看交换文件的位置。

第九章 奇技淫巧
	多文件替换：
		可以用宏来做。比如替换所有cpp中的return 0;为retnurn 1;
		vim *.cpp
		qq
		%s/return 0;/return 1;/ge	g表示替换一行中所有匹配字符，e表示即使出错也继续
		:wnext
		q
		999@q
	排序：
		如果想对某一段文本进行排序，可以用如下命令：
		:range!sort
		or
		:.,/^$/-1!sort	.代表当前行，/^$/代表空行,-1代表空行的前一行，即从当前行到空行之前一行进行排序,!sort调用外部sort程序。
	逆序：
		将所有文本逆序排列
		:g/^/m 0	g表示global，^表示匹配一行，m表示move,0表示移动到首行之前。
			[range]move(m){pos}
	统计字数：
		g<ctrl-g>	会在状态栏中显示当前文件的统计信息。
	调用man：
		:source $VIMRUNTIME/ftplugin/man.vim 
		:Man xx 
	使用grep
		vim内置grep，其实调用了外部grep程序。
		:grep something files 
		此时会打开第一个匹配文件。

第十章 加速冒号命令
	在命令行窗口可以：
		tab	:自动补齐
	历史命令：
		vim的历史命令有四个记录：
			冒号命令记录，/,?的搜索记录
		冒号命令记录：
			如果记得命令的开头几个字母，在:后输入字符，然后用上下键进行查找。
			ctrl-p同上键，ctrl-n同下键。prev，next。ctrl-u取消，此时可以重新输入命令。
		:his /	查看用/进行查找的记录。注意不是在his中进行查找
		:his ?	查看用?进行查找的记录
		q:		打开冒号命令记录。此时光标在命令记录窗口中，处于normal状态.
				此时可以通过光标移动，可以通过/来查找命令。按i，进入编辑状态，编辑好了按回车就可以执行该命令。

第十一章 进退之间
	记住编辑信息
		正如前面几章所描述的：
			vim可以做标记marks，用`来跳转。
				用mx做标记，用:marks查看
			vim通过寄存器可以记录宏，复制内容等
				用qx，"xy{motion},来标记;用:reg查看
			vim可以记住命令，用his来调出
				:his 
		以上这些内容存在于一个叫viminfo的文件中.
		可以将viminfo保存到一个文件中，以共享
		:wviminfo! file 
		:rviminfo file 
		默认的时候是.viminfo文件,保存在用户的己目录下。是一个全局属性。
	保存会话状态：
		会话状态保存当前的全局变量，窗口位置，选项等。这样就可以在上一次停止的位置继续进行。是一个局部属性。
		:mksession file 
		:source file 
		或vim -S  file
		如果不带file，则默认是在当前目录建立一个Session.vim文件
		session和viminfo是不同的，viminfo自动建立，session如果需要可以手动建立。
	窗口状态：是一个局部属性。
		如果想记住窗口的分布状态可用:mkview,然后用:loadview(lo),来恢复。
		如果有不同类型的窗口可用：mkview number,然后用：lo number来恢复。
		或者用:mkview file ;:source file来恢复 
	模式行：
		对于某些文件，需要一些特别设置，而又不希望是全局的设置（直白的说就是希望改变.vimrc文件中的设置），这些设置不需要每次手动改变。
		vim提供的方法是在该文件中放入这些配置。
		语法是：any text vim:{option}={value}...
		any text的意思是任意文本
		比如 // vim: tw=72 
		在vim之前必须有一个空格，vim识别vim:关键字

第十二章 文件查找
	文件浏览器：
		:edit .	可以以当前目录，打开一个文件浏览器。这时可以用上下键选择其中的文件enter打开该文件。
		也可以
		s：排序，r：逆向排序
		o：打开新窗口
		p：预览文件
		R：重命名
		D：删除文件
		i: 显示大小日期信息（此时，将光标移动到日期或大小栏，按s，r可以按照大小或日期排序）
		c: 将当前目录改变到光标所在文件的目录。
		ctrl-o回退到原窗口
	当前目录：
		:cd	..	改变当前目录 
		:pwd	显示当前目录
		:lcd	改变当前窗口的目录，不会影响其他窗口
	查找文件：
		gf	将光标移到文件名处gf。这个对于编辑程序很有用
		:find xx
		:sfind xx	开一个新窗口来显示文件
		设置查找路径
		:set path+=...
	缓冲区
		对于每个打开的文件对应一个缓冲区
		:buffers	显示当前的缓冲区
		:ls			同样的作用
		缓冲区标志：
			+	有改动
			-	不可改动
			u	未列出的缓冲区
			h	隐藏的缓冲区
			%	当前缓冲区
			a	正在编辑的缓冲区
			#	上次活动的缓冲区
		:buffer(b) xx	显示buffers中列出的文件，xx是数字。这样就可以不敲入文件名。
		:sbuffer(sb) xx	开一个新窗口
		:bnext(bn)		下一个缓冲区
		:blast(bl)
		:bfirst(bf)
		:bprivious(bp)
		:bdelete(bd) xx	删除缓冲区。当删除一个缓冲区，其不再buffers列表中显示，但是如果用:buffers!,或:ls!还是可以显示的。

第十三章 编辑非文本文件
	关于文本格式
		在unix系统，文本以LF作为行尾，在Windows系统已CR,LF作为行尾，Mac系统以CR作为行尾。
		CR	carrier return	：ascii码为13
		LF	line feed		：ascii码为10
		vim可以自动识别以上格式。但是对于Mac可能会出错。
			在vim中用<CR>代表回车键，导致建立新行，实际上在行结尾加上LF，不要搞混了。
			在vim中用
				\r	代表<CR>，结果是在行尾加上LF（10），并进一行。
				\n	代表行尾。
				比如：
				nmap aa iabc\r
				意思是在normal模式下将aa映射为在当前光标处插入abc并回车换行。
				而nmap aa iabc\n并不能换行，只能在行尾加上一个00字符。
			而在printf函数中
				\r	代表回车，回到行首
				\n	代表另起一行
			所以转义字符在不同程序中所代表的意义并不相同。
		:set fileformats	查看vim识别的文本类型。默认是unix，dos。可以加上mac	:set fileformats+=mac
		:set fileformat	查看当前文本类型。
	因特网文件：
		URL		：在文本中输入URL，然后用gf可以获得因特网文件。
			支持的类型有：
				ftp://
				scp://
				rcp://
				http://
			vim实际是利用外部程序来获得以上文件，所以可能需要安装相应软件
	二进制文件：
		vim可以利用xxd程序来显示二进制文件
		:%!xxd
		or
		:%!od od是另一个二进制显示程序
	压缩文件
		vim可以直接显示压缩文件。同二进制文件一样，其也是调用外部程序。
		支持的压缩文件包括：
			.gz		gzip
			.bz2	bzip2
			.Z		compress
			这些文件可以直接显示原文，保存时保存到压缩文件中。
	加密文件：
		vim -x file	给文件加密，此时输入密码。下一次打开的时候不需要-x，此时vim需要你提供密码。保存就直接保存，不需要密码。
		:set key=	可以去掉密码。注意要保存，否则不会去掉。
		:set key=xxx改变密码
		:X			改变密码，不过密码输入时，显示的是*

第十四章 快速键入
	灵活使用移动
		要对光标移动熟悉：
		normal状态下：
				w	下一个单词首
				b	前一个单词首
				e	下一个单词尾
				ge	前一个单词尾
				j	下
				l	右
				h	左
				k	上
				a	插入
				A	插入行尾
				i	编辑
				I	编辑行首
				r	替换
				R	替换模式
				o	插入下一行
				O	插入上一行
		为了在编辑模式下也可以快速移动光标，而不用手离开字母区，可以定义一些编辑模式下的光标移动键：比如
		:imap <C-h> <left>
		:imap <C-l> <right>
		:imap <C-j> <down>
		:imap <C-k> <up>
	自动补齐
		在输入文本的时候，可以通过ctrl-p来补齐后面的内容。如果候补的内容不止一个，则会在一个列表中，
		此时可以用ctrl-p前翻，ctrl-n后翻。ctrl-u放弃。补齐部分的内容来自：
			当前行
			当前文件其他行
			其他窗口
			隐藏的缓冲区
			非活动的缓冲区
			tag
			#include文件

			特殊的内容：
			ctrl-x ctrl-f	文件名
		    ctrl-x ctrl-d	宏定义
			ctrl-x ctrl-l	当前文件的一行
			ctrl-x ctrl-]	tag
	重复键入：
		在每次进入，退出编辑模式时所键入的内容被保存，此时可以在编辑模式下用ctrl-a粘贴这个内容。（感觉此功能不太实用）
	复制上一行字符：(编辑模式)
		ctrl-y可以从上一行相同列的位置复制字符。
			比如：上一行为
				a->next=b->next
				下一行将next改为prev，则可以在下一行一直按ctrl-y直到>
				然后修改为prev，再继续按ctrl-Y，修改下一个。
			ctrl-e是从下一行复制。
	从寄存器复制：
		"xyiw	normal状态下，将光标移到一个字串上，然后输入以上命令，此时将光标下的单词复制到x寄存器。x是寄存器名，y表示复制，iw表示这个单词。
		也可以在visual状态下，先选择要复制的字串，然后敲入"xy,也可以将选择的内容复制到寄存器x中。
		ctrl-r	在编辑模式下，键入ctrl-r，此时会提示",此时输入刚才的寄存器名。
	缩写：abbreviation（编辑模式）
		在输入字串时，可以用一个缩写来代替一串字符。
		:abbrev def some words
		在键入时可以只输入def，空格后或换行后vim就会自动替代。

		利用abb也可以构造一个单词拼写修改记录，将经常输错的字符替换成正确的字符。比如:abbrev teh teh
		:abbrevia(ab)			列出缩写
		:unabbrevia(unab)	xx	删除缩写
	键入特殊字符：(编辑模式)
		如果在输入过程中输入一个特殊字符，而不想让vim解释成特殊意义，可以用ctrl-v。
		比如在文本中输入中按下ESC键，此时你的意思是要在文本中输入ESC这个键，而不是退出编辑模式，
		此时就可以先按ctrl-v键，然后再按esc键。
		 -这个就是输入结果。
		ctrl-v 后面可以跟
			十进制数字	比如13	代表CR
			o	num	八进制
			x	num	十六进制
			u	num	16位
			U	num	32位
		:digraph 可以显示当前vim中定义的字符。
		ctrl-k	xx	输入vim中定义的字符。但是ctrl-k已被上面的光标移动占用了。用ctrl-v一样输入。
			比如ctrl-v 174 输入的是：®
	在编辑模式下使用normal模式：
		编辑模式下移动光标不太方便，需要先ESC，然后再insert。
		vim提供快速的方式：
		ctrl-o command	ctrl-o可以暂时退出编辑模式，执行noraml方式下的command，然后返回编辑模式。
			比如：ctrl-o ''

第十五章 格式化文本
	断行
		:set textwidth(tw)=xx	设置每行的宽度
		格式化：
		[range]gq	gq是格式化的意思，可以在visual模式下选定范围比较方便
		gq{motion}	比如gf4j
		gqap		ap是文本段
		gggqG		整理所有文本
	对齐文本
		:{range}center[width]	中间对齐，width是宽度。如果未指明，默认是tw。
		:{range}left[margin]	左对齐，margin是左边空格,默认是0
		:{range}right[width]	右对齐，width是宽度
	缩进
		:se autoindent(ai)	设置自动缩进，每新行沿用前面一行的缩进。
		:se noautoindent(noai)	:关闭自动缩进
		:se shiftwidth(sw)	:设置每次缩进的缩进量
		>{motion}	:增加缩进
		>>			:增加本行缩进
		<{motion}	:减少缩进
		<<			:减少本行缩进
	tab宽度：
		:se tabstop xx	
	长行文本：
		:se wrap	回绕
		:se guioptions+=b
	表格：
		:se virtualedit(ve)=all	设置virtual 模式，虚位置。即使后面没有内容，光标也可移动。画表格的时候有用。
		:se ve=	取消设置
			_________________________
			|table1|table2   |table3 |
			--------------------------
			|ccc   | aaa     |       |
			--------------------------
			|cccl  |         |       |
			--------------------------
			|2005  | 2007	 |   	 |
			--------------------------
			|______|_________|_2010__|						 

第十六章 重复
	visual模式下的重复
		在visual模式下选定文本并操作后，可以用gv来再次选择该文本，做动作。
		比如对上面的表格将ccc替换成bbb，将aaa替换成ccc。可以：
		先sel然后：
		<.,.+10>s/ccc/bbb
		然后gv
		此时又选中文本，执行
		<.,.+10>s/aaa/ccc
	改变数字
		比如上面表格中的数字，选中后(visual模式下/200[0-9]),然后按ctrl-a可以增加数字。
		ctrl-a	+
		ctrl-x  -
	多个文件
		对于多个文件的操作，可以利用前面所说的宏，也可以利用args参数
		:args ...输入文件名。可以使用通配符
		:argdo command
		比如替换所有c文件中的return 0为return 1
		:args *.c
		:argdo %s/return 0/return 1/ge | update
		ge	:g表示对每行所有匹配元素，e表示出错继续，update会在文件改变时保存。
		argdo 也可以是windo，表示对所有窗口操作。
	在shell中调用vim
		扩展命令模式：ex
			vim命令行有-e选项，此时vim进入扩展命令模式，将输入脚本解释成命令模式下的命令:command
			比如完成以上同样的功能可以这样做：
			先写一个vim脚本cc.vim
			%s/return 0/return 1/ge
			write
			quit

			然后在shell中输入：for i in *.c;do vim -s -e $i < cc.vim;done
			-e	表示启用ex模式
			-s	表示silent
		normal模式：
			vim -s script files
			此时vim进入normal方式，-s 表示后面是noraml模式下的命令。
			用此方法需要用script描述动作。
			可以用vim -w script file 来记录动作到script文件中，此时可以正常操作，然后用-s来执行。
			-w	是追加方式
			-W	是重写方式

第十七章 搜索
	忽略大小写：
		:se ic		忽略大小写
		:se	noic	大小写敏感，精确
		:se ic smartcase(scs) .这种方式下，如果所敲入的匹配字串有大写字母，则是大小写敏感。
		正则表达式中的大小写
			\cpattern	忽略大小写
			\Cpattern	不忽略大小写
			比如/\CWord	只能匹配Word
			用\c，\C方式优先于ic，smartcase方式。
	回绕：
		:set wrap
		:set nowrap
	偏移：
		当匹配时，默认光标会停在匹配单词的第一个字符。
		/pattern/number	,number用来设置匹配时光标位于匹配行的偏移number行
		/pattern/ex		:光标位于匹配单词尾,x表示偏移的数量，+n，-n
		/pattern/bx		:光标位于匹配单词首,x表示偏移的数量，+n，-n
	懒惰模式
		正则表达式一般尽可能多的匹配字符，比如/tex.*t/可以匹配text,texxt,tex3t等，
		而如果用/tex.\{-}t/,则只能匹配text，tet，tebt，不超过4个字母。
	匹配空格或断行
		/\n/	断行
		/_s/	空格或断行
	其他参见正则表达式，是一致的

第十八章 折行
	对于一个结构化文本，可能由多章构成，每章有多段，每段有多节。
	对于一个源程序文档，可能由不同的缩进表示代码的层次。
	通过折行，可以将同一章，段，节或层次的内容折叠起来，就像将一张纸折叠起来一样，在折叠处显示折叠起来的内容的首行内容，这样更容易看清文档的结构。
	折行的操作都是在normal状态下执行。
	1) 手动折行
		手动折行就是手动定义折行的内容。
		zfap ：折行定义。
			z可以理解为折叠，f->flag，zf表示定义折叠，ap表示以下文本内容。
			在vim（或其他很多文本处理程序）中将没有分行的文本作为一段连续的文本，作为一段，即使在屏幕上我们看到两段之间是分行的。比如：
			aaa
			bbb
			上面的内容我们看到的是两行，但是实际上vim将aaa，bbb解释成一段，只有两行之间空一行，才认为是两段。如：
			aaa 
		
			bbb
		zc	:z close 折叠起来
		zo	：z open 折行打开，在折行的地方按空格也可以打开折行。
		zr	:减少折叠层次，折叠打开。与zo所不同的是对全文有效，而zo仅仅是对光标所在的折叠处有效。
		zm	:增加折叠层次，折叠起来。是zr的反命令，与zc不同的地方与zr命令一样。
		zR	：全文展开。
			与zr命令所不同的是，zr每次仅减少一层的折叠层次，如果有比此层更深的层次则不展开，
			而zR为尽可能的展开更多的层次，即将所有折叠的地方都展开。
		zM	：全文折叠。
			与zm命令所不同的是，zm每次仅增加一层的折叠层次，此层的上一层并不折叠，
			而zM则尽可能的折叠更多的层次，即将所有能够折叠的地方都折叠起来，这时可以比较清楚的看到文档的大纲。
		相关命令：
		:set foldmethod[=xx]	设置折叠方法，xx可以是manual，indent，marker，expr。
			manual是手动设置折行标记，用zf命令，在其他方式下zf命令无效。
			indent是根据缩进设置折行标记。自动进行。
			marker是根据文本中的{{{[x]来设置折行标记，x是表示折行深度的数字（1,2,3..)。
				如果不带数字在折行结束的地方需要写上}}}，如果带数字则vim会自动认为前面的折行结束。
				这种方法的缺点是在文本中需要手动加上折行标记。
			expr是通过编辑的一个表达式来计算折行标记。用:set foldexpr=xxx来设置。比较麻烦，就不写了。
			比较常用的是manual和indent方式。
		:set foldlevel	设置折叠深度。
			set foldlevel=0表示尽可能折叠。zr，zm,zR,zM命令实际上是改变foldlevel数字来实现的。
			数字越大，表示需要折叠层次越高，即只有达到这个层次的地方才折叠，也就是展开。
			数字越小，表示需要折叠的层次越低，即只要达到这个层次的地方就折叠，也就是折叠。
			所以zR命令会在全文查找折叠层次，取最大值作为foldlevel。zM命令将foldlevel设置成0。
	2) 自动折行
		:se foldmethod=indent 或marker，expr 
		:se foldlevel=0.可以根据情况来设置。如果在编辑的时候折行乱了，可以用此命令，重新折行。
		:set foldopen=xx	:当光标移动到折行时,自动打开
		:set foldclose=xx	:当光标离开折行时,自动关闭
		xx默认有block，quickfix，tag等。可以将xx设置成all。	
	3) 折行状态保存
		:mkview(mkvie) x x是需要保存的视图状态数字，可以保存10个视图状态。
		:loadview(lo) x 装入视图。

第十九章 之于程序
	tag
		利用tag可以对文本做标记，这样就可以快速到找到想要的地方。mark也相当于是tag，但是需要手动标记。
		ctags是一个生成标记的程序，在shell中执行ctags -R，-R表示递归。
		默认是为当前目录下所有文件生成名为tags的tag文件。-f 可以指定输出文件名。
		然后在vim中执行
		:se tag+=tags
		:tag(ta) xx	:查找名为xx的tag，如果找到将直接跳到该tag处。命令方式
		ctrl-]	:将光标移动到待查找的单词，按ctrl-],如果找到，也可以跳转。
		ctrl-t	:跳回来。
		ctrl-w ]:在新窗口打开跳转处。ctrl-w表示获取光标下的单词。
		:tnext(tn)		:跳转到下一个匹配的tag
		:tprevious(tp)	:前一个
		:tlast(tl)		:最后一个
		:tfirst(tf)		:头一个

		:tselect(ts) xx	:打开一个tag选择窗口，如果有多个匹配的tag
		:ts /xx			:用正则表达式来搜索tag
		ta,ts命令的不好之处在于会在当前编辑窗口打开tag，为了避免以上问题,可以开一个预览窗口preview
		:ptag(pta)	xx
		:ptselect(pts) xx
		:pts /xx	
		:pclose(pclo)	关闭预览窗口

		:set taglength(tl):设置匹配tag的长度					 
		tag浏览器：
			:split(sp) tags	在新窗口打开默认的tags文件。如果生成的tag文件是另外的名字，则输入另外的名字。
			:setlocal(setl) ts=99	清理一下,setlocal，同set但是仅对当前buffer有效。	
			:nmap <buffer><cr> :tag <c-r>=expand("<cword>")<cr>
				nmap表示映射一个noraml map
				<buffer><cr>	表示要映射的动作，在buffer区按下回车键
				:tag	命令
				<c-r>	在输入状态下的命令替换
				expand	展开函数
				<cword> 取光标下的单词	<c-w>描述一个normal状态下取词动作
				<cr>	回车
			以上命令也可以用：
			:nmap <buffer><cr> "aye<c-w>:tag <c-r>"a<cr>,意思是将光标下的单词放到寄存器a中，然后用tag跳到a寄存器中的内容处。
	cscope 
		cscope是另一个tag程序 
		建立tag
			cscope -bR
		vim链接cscope
			:cs add cscope.out 
		使用：
			在光标所在单词处按  
			ctrl-\s	:search c synbol
			ctrl-\g	:search define
			ctrl-\d	:search functions called by this function 
			ctrl-\c	:search functions call this function 
			ctrl-\t	:same as c

第二十章 程序的编辑
	编译程序：
		vim允许在vim环境中编译程序，而不用退出。
		:make {parameter} 
		vim实际上是调用外部程序来编译。
		:set makeprg=xx	:设置所调用的make程序。
			举例：
			:set makeprg=make
	缩进
		c语言的缩进可以用
		:se cindent 打开。其可以自动根据{}，#if等来缩进
	自动缩进
		需要：
		:filetype		检查当前文件检测相关的设置
		一般有:filetype detection:on indent:on plugin:on 
		:filetype on	打开文件类型检测
		:filetype indent on	根据文件类型选择缩进方式
		:se filetype	:检查当前文件类型
		:se runtimepath	:检查当前vim查找script的目录
		自动整理代码：
		gg=G	vim自动对全文处理缩进
		其他缩进
			前面已经提到
				:se autoindent
				:se smartindent	:没有cindent考虑周到
			缩进量
				:se shiftwidth=xx
			在编辑模式下增减缩进量,每次增减1个shiftwidth。	
				ctrl-t	+
				ctrl-d	-
			利用>,>>,<,<<
				>i{		为{...}中的内容增加缩进
				>a{		为包括{}增加缩进
				<i{		为{...}中的内容减少缩进
				<a{		为包括{}减少缩进
				increase，append
	制表符tab
		:set tabstop=xx, 4或8
		:set softtabstop=xx	,制表符和空格混合
		:set expandtab	:只用空格
		:%retab	将tab转换成空格
		:%retab!反之
	整理注释：
		gq]/	效果是将多行整理成一行，根据textwidth
			将光标移动到注释开头，然后执行命令
			gq是整理文本的意思。]/寻找注释结尾。
			或者用visual模式，选择后gq
	自定义整理注释：
		:se comments=xx, xx内容是{flag}:{comment key text}
			举例：:se comments=://,s1:/*,ex:*/
			指明了注释的关键字
			flag
				s	start
				e	end
				m	middle
				num	offset to right
				x	结束	
				详细说明 参见h format-comments
		如果要自定义注释内容可以用abbreviation(abb)
		举例：
			:abb ii /*<cr>author:xxx<cr>*/

第二十一章 定义新命令
	除了vim自带的功能外，用户可以定义自己的命令，以方便自己使用（定制化）。这些命令包括：键映射，冒号命令，自动命令。
	键映射
		键映射可以新建或改变快捷键，以加速动作。
		定义map
			:map mapto command
				map 是建立键映射的命令
				mapto 是将要新建的映射动作的名字
				command 是该映射所要执行的动作。
			map可以有多种模式
				映射命令	模式
				map			normal visual operator-pending
				nmap		normal
				imap		insert
				vmap		visual
				cmap		command
				omap		operate pending
				map!		insert and command
				operate pending是等待动作的模式比如按下d后，vim等待继续的motion操作。
				举例：比如要定义F7来删除后面一段文本
				omap <F7> a{
					a{	就是一个motion。 a代表1个，{代表向后匹配段
					这样当键入d<F7>就可以删除后面一段内容。
				关于motion可以参见:h motion.txt
			为了防止在映射中再次映射，可以定义noremap
				映射命令		模式
				noremap			normal,visual,operate pending
				nnoremap		normal
				inoremap		insert
				vnoremap		visual
				cnoremap		command
				onoremap		operator pending
				noremap!		insert and command
		显示map
			:map 
			:nmap
			:..
		删除map：
			unmap	normal,visual,operate pending
			nunmap	normal
			iunmap	insert
			vunmap	visual
			cunmap	command
			ounmap	operator pending
			unmap!	insert and command
		特殊字符：
			在映射中
			|	表示执行多个命令	如：map <F2> write <Bar> | ls
				如果命令中出现|,则用<bar>代替命令中的|
			<space>	空格
		特别的，在mapto前加上：
			<buffer>	表示针对当前缓冲区
			<unique>	表示唯一
			<script>	表示针对该脚本
			<nop>		表示该映射不做任何事，nop后面必须没有空格
	自定义冒号命令：
		自定义冒号命令是建立新的命令模式下的新命令。目的是简化手动敲许多命令以完成某项功能。
		建立命令：
			:command newcommand command
				用户可以自定义命令，注意newcomman的名字第一个字母需要大写
				command就是用户在命令模式下所能输入的命令。
				其实就是将繁琐的命令输入，简化了。
				比如：
					:command Da :echo "hello"
					:Da		执行
					:hello	结果
			设置参数数量
				:command -nargs=xx command	
					xx		代表参数数量
					?		0,1
					*		>=0
					+		>=1
					举例：
						:command -nargs=+ Say :echo "<args>"
						echo 在当前命令行窗口显示
			使用参数
				<args>		定义的时候要加" ",否则出错
					:command -nargs=+ Say :echo "<args>"
					:Say a b c
				<q-args>	可以不加" "
					:command -nargs=+ Say :echo <q-args>
					:Say a b c
				<f-args>	给函数用的
					举例：
					:command -nargs=* Say :call Afun(<f-args>)
					:Say a b c
					等同于：
					:call Afun("a","b","c")
			其他选项
				-buffer	只对当前缓冲区有效
		查看命令：
			:command	列出当前用户自定义命令
		重定义命令：
			:command! ...	!表示强制覆盖
		删除命令:
			:delcommand xx
	自动命令：
		自动命令是在某种事件触发时所要自动执行的命令，可以完成某些自动化功能。
		建立命令
			:autocmd [group] events	{pattern_files} [nested] command
				group	用来分组
						分组的命令用来对autocmd命令进行分组，以方便查找，删除等动作。
				events	事件
					BufReadPost	将要编辑一个文件
					FileType	检测文件类型，如果正常检测到一个文件类型
					BufNewFile	建立新文件
					...
				pattern_files:
					文件匹配
				nested	递归
				command	command是在命令模式下所输入的命令.
					举例：如果文件是c，cpp文件，则在输入{的时候，自动输入匹配的}，并在中间插入一行。
					:autocmd FileType *.c *.cpp inoremap { {<cr><esc>}O
					如果想用normal模式，则在命令前用normal，相当于在命令模式下输入normal进入normal模式。
					比如：autocmd BufNewFile *.c normal G,将光标移动到最后。
					command 可以用execute “...”来包括
					可以强制触发另外的命令doautocmd events
					如果对同一事件有多个定义，则会依次执行。
				vim内置事件：
					:h autocmd 
				gourp的用法：
					定义命令的时候可以：
						:au xxgroup		：xxgroup是组名，表示定义该组命令的开始
						:au events pattern_files command	：定义该组的自动命令
						...
						:augroup end ：结束该组命令定义
					it same as
						:au xxgroup events pattern_files command 
						:...
				
		查看命令：
			:autocmd		所有自动命令
			:autocmd group  查看某个组的自动命令
			:autocmd events 查看某个事件自动命令
			:autocmd * file_pattern	查看某个类型文件自动命令
		重定义命令：
			:autocmd!...
		删除命令
			:autocmd! events * ,这将删除该事件的所有动作

第二十二章 vim脚本
	前面自定义键，命令是应用于比较简单功能的场合。对于比较复杂的功能就需要将多条语句进行组合，这就是脚本的应用场合。
	脚本中的元素包括：变量，数组（链表，字典），表达式，程序控制语句，函数。
	变量
		定义变量：
			变量名符合大多数变量名定义规则，变量名开头不能是数字，内部不能包括+。
			:let var=val 在脚本中:可以不要，但是为了区分命令模式，最好还是加上。
			=两边不要有空格
			变量范围：
				在变量前可以加上限定词以限定范围
				s:	local
				g:	global
				w:	window
				b:	buffer 
				v:	预定义
				比如:let s:a=1	限定于本脚本，局部变量
			数字变量
				可以是十进制，十六进制，八进制
				举例：
				let a=0xf1	十六进制
				let a=033	八进制，前面的0表示8进制（与shell一样）
			字符串变量	
				let var="..."	扩展
				let var='...'	不扩展
				var1 . var2 字符串连接
				举例：let a="\naaa",echo a，会打印换行，而let a='\naaa'则不会换行，直接打印\naaa
			列表：list
				定义
					:let var=[...]	,数组下标从0开始
					:let var=[...]+[...]
					比如：:let var=[1,2]
				引用：
					var[index]
					var[from:to]
					比如：
					let a=var[index]
					let a=var[from:to]
			字典：dictionary
				定义 
					:let var={}
					:let var[expr1]=expr2 
						let var["hello"]="world"
				引用：
					echo var["hello"]
		变量引用：
			在vim中定义的用户变量直接引用
				举例：
					let a=12
					echo a
			内部变量引用：
				$var	shell环境变量 如$VIMRUNTIME
				&var	选项 如&tw
				@r		寄存器 如@1
		变量删除
			unlet xx 
	表达式
		运算符:
			+,-,*,/,%,(,),{,},=,a?b:c
		逻辑符
			==,!=,>,>=,<,<=,
			=~正则表达式匹配
			!~反之
		执行表达式
			:echo ...
			:execute(exe) "expr1 ..." 将表达式放在字串中执行
				expr1后面可以跟参数，用空格分开，比如：
				:exe "buffer" nextbuf
				如果有多个字串可以用.来连接
				exe可以执行|，并行操作
				比如：exe "delfun fun1|delfun fun2"

	程序控制
		if condition
			statement
		else if condition
			statement
		else
			statement
		endif

		while condition
			statement
		endwhile 

		for var in list
			statement
		endfor 	

		continue
		break
		return
		try
			statement
		catch	[Exx]	Exx是错误号，如果没有，则捕捉所有
			statement
		endtry
	函数
		函数定义
			function [def] name (argument) [range]
			函数名第一个字母需要大写
				def	表示函数范围
					s，g，v，w
					比如：
					function s:Max(num1,num2)
				argument	参数 
					用a:var来引用变量
					比如：
						function Max(num1,num2)
							if a:num1>a:num2 
								return a:num1
							else
								return a:num2
							endif
						endfunction
					未知个数的参数
						function fun(arg1,...)
							a:0	表示参数个数
							a:1	第一个参数
							...
						endfunction

				range	表示使用行号范围
					vim的命令前面一般可以加范围，函数可以使用这个范围
					用a:firstline,a:lastline来引用变量
					比如：统计一段代码的单词数
					function SumLine()range
						let n=a:firstline
						let count=0
						while( n<a:lastline )
							let count=count+Wordcount(getline(n))
							let n=n+1
						endwhile
						echo "count ".count."words"
					endfunction
					"还不完善
					function Wordcount(str)
						let s:index=0
						let s:pos=0
						let s:countw=0
						if strlen(a:str)==0
							echo "str is 0 len"
						else 
							while s:index != -1
								let s:index = match(a:str,'[ \t:{}";+=()]\{1,10\}',s:pos)
								let s:pos=s:index+1
								let s:countw=s:countw+1
							endwhile
						endif
						echo " count ".s:countw." words" 
						return s:countw
					endfunction
			vim内置函数
				:h function-list
				ctrl-]	跳转到定义
				map		：map(expr1,expr2)
					expr1是list或dict
					expr2是针对expr1中的每个元素的操作
						v:key is key 
						v:val is value
						if expr1 is list key is index from 0
						if expr1 is dic  key is key 
					结果是将expr1中的值替换成expr2中的计算结果。
					example:		
						:let a={"a":"zzaa","b":"zzbb"}
						:let geta=map(copy(a),'v:key . " is " . v:val')
						:echo geta
						result is 
						:{'a':'a is zzaa','b':'b is zzbb'}
						expr1中用copy是防止修改原字串。
						expr2中用''表示不展开，.表示连接字串。

		执行函数：
			:call fun 
		显示函数
			:function(fun)	显示全部 
			:fun /regular	查找 
		删除函数：
			:delfunction(delfun) fun 
	用户plugin:
		通过以上元素的组合就构成了能完成某些功能的脚本，这些脚本作为插件（plugin）被vim启动时自动装入。
		用户plugin有两种，一种是全局的，一种是与文件类型相关的。
		全局的放在$VIMRUNTIME/plugin目录下。
		文件类型相关的放在$VIMRUNTIME/ftplugin目录下。(ft->filetype)
		$VIMRUNTIME代表vim的运行路径。
			系统的一般是/usr/share/vim/vimxx，xx是vim的版本号。
			用户的一般是~/.vim 
		比如上面写的关于统计单词数的脚本就可以保存到~/.vim/plugin目录下。
		vim启动时会自动加载该文件。
		全局plugin
			新建全局plugin
				为了避免重加载可以在文件开头定义以下语句：
				if exist("loaded_a")
					echo loaded a.vim
					finish
				endif
				let loaded_a=1
				相当于c语言中的头文件使用方法。
				<SID>
					SID用于将函数唯一编号，这样就与别人同名的函数不冲突。
					functon <SID>Myfun()
						Statement
					endfunction
					nmap <leader>s :call <SID>MyFun()
			帮助文件
					在首行用*...*包住
					比如：
					*test.txt* 用helptags生成索引的时候会用到
		文件plugin
			文件plugin用来针对某种类型文件的动作。比如设置开头的文字。
			设置文件类型
				:setfiletype(setf) xx	但是一般不这么用，而是根据匹配情况来自动设置
				根据后缀名设置：
					:autocmd events pattern setf xx 
					例如：
						:au BufNewFile,BufReadPost *.h  setf h
						将该句放在$VIMRUNTIME/filetype.vim中
						其实系统的filetype.vim文件中有许多预定义的文件类型，一般不需要修改。
						但是我发现对于h文件并没有好的设置，所以我在~/.vim/目录下建立一个filetype.vim
						if did_filetype()
							finish
						endif
						augroup filetypedetect
						au BufNewFile,BufRead *.h setf h
						augroup end 
						"did_filetype"代表是否允许filetype检测，通过:filetype on来设置。
					需要指出的是文件类型也可以不对应后缀名。比如.m文件在vim中的文件类型就是matlab。		

				根据文件内容设置
					一些脚本一般在文件开头有一些信息，可以用来确定文件类型。比如：
					#!/bin/bash 
					这时可以用匹配字串的方法：
						if did_filetype
							finish
						endif
						let name=getline(1);
						if name~='^!.*\<bash\>$'
							setf bash
						endif
				在设置了一个文件类型后，如果后面脚本继续设定将被忽略。		
			新建fileplugin：
				文件plugin放在$VIMRUNTIME/ftplugin 目录下。名字以新建文件类型命名。
				比如建立一个h类型文件，命名为h.vim。这里放针对h类型文件的动作。
	vim脚本的执行顺序：
		通过:se runtimepath可以看到vim脚本的搜索路径：
		runtimepath=~/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/vim/vimxx,usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,~/.vim/after
		即：
		~/.vim,
			/var/lib/vim/addons,
				/usr/share/vim/vimfiles,
					/usr/vim/vimxx,
				/usr/share/vim/vimfiles/after,
			/var/lib/vim/addons/after,
		~/.vim/after
		所以用户目录下的.vim目录下的脚本，除了after目录最后执行外，其他都是首先执行。如果与系统的脚本名同名，也是首先执行。
	其他：
		<LocalLeader>	local for \
		cpoptions(cpo)	compatible options 
			:se cpo=aABceFs
				aA...是一组具有特殊意义兼容性标志。
				比如a，代表当:read 时，将文件名以当前窗口的文件名为文件名。
				参见:h cpoptions
		
第二十三章 语法高亮
	语法高亮的脚本位于$VIMRUMTIME/syntax目录下。对应每种文件类型有一种高亮文件
	用户也可以创建一个自己的高亮脚本，并放在~/.vim/syntax目录下。
	建立语法文件：
		:syntax(syn) keyword {group} keyword ...
			用关键字匹配
			举例：
			将goto break等控制语句放一组cStatement中
			:syn keyword xStatement goto break return continue asm 
		:syn match {group} regular
			用正则表达式匹配
			:syn match xIndentifier /\<l\>/
		:syn region {group} start=/.../ end=/.../
			区域匹配
			:syn region xString start=/"/ end=/"/
		:syntax keyword {group} keyword contained 
			嵌套匹配
			:syn keyword xTodo TODO contained
			:syn region xComment start=/\/\*/ end=/\*\// contains=xTodo 
			前者定义一个todo的匹配，后者定义一个/*...*/的匹配 
			这样对于/*This is TODO*/的注释，对于TODO将以另外的形式显示。
			嵌套匹配的一种形式是递归匹配
			比如：
				:syn region xBlock start=/{/ end=/}/ contains xBlock
			contains 可以有多个限制
				ALL	包括所有
				ALLBUT 所有但排除
				  :syn region xBlock start=/{/ end=/}/ contains=ALLBUT,xTodo
				TOP	包括没有contained标志的组
				contained	只包括有contained标志的组
		:highlight(hi) link group1 group2
			将group1连接到group2上高亮
			举例：
			:hi link xStatement Statement 
		:syn sync ...	表示同步。在编辑的时候也匹配
			...可以象前面的一样定义
			也有一些参数
			minline=xx	从前面多少行开始解析
	包括另外的高亮文件
		:rutime! other_syntax.vim 
		:runtime(ru)! [where] {file}
		runtime命令从runtimepath路径中查找扩展脚本文件并执行。!表示所有找到的文件。
		另外一个装载脚本文件的命令：
		source(so)[!] file 
	可移植的高亮文件
		文件头
		" Vim syntax file
		" Language:	C
		" Maintainer:	Bram Moolenaar <Bram@vim.org>
		" Last Change:	2012 Jan 14
		
		" Quit when a (custom) syntax file was already loaded
		if exists("b:current_syntax")
		  finish
		endif
	
第二十四章 多语言
	设置语言
		:language(lang) 查看当前语言
			选择语言目的是当选择该语言时vim现实的信息都是该语言的。
			如果返回是C，是默认的英语。
			lang是一个环境变量。来自于shell中的LANG。
			系统所支持的语言在/usr/share/local/ 
			可以选择一个：export LANG=xx 
			vim所支持的语言在$VIMRUNTIME/lang/ 下面	
		:se langmenu=xx 设置菜单的语言
			菜单用的是$VIMRUMTIME/lang/menu_xx.code.vim 
			如menu_zb_cn.utf-8.vim 
	设置编码：
		:set encoding=xx		vim buffer的编码
		文件编码
		:set fileencodings=		文件编码集
		:set fileencoding=xx	文件编码
	输入：
		digraph 
		或输入法
======================================================================
附录1：关于motion 
	motion是移动命令，比如hljk。但是vim中的motion比这丰富的多。
	see also by	:h motion.txt 
	将motion命令与编辑命令结合，可以加快编辑的速度。
	可以与motion结合的编辑命令：
		c	change
		d	delete
		y	yank into register (does not change the text)
		~	swap case (only if 'tildeop' is set)
		g~	swap case
		gu	make lowercase
		gU	make uppercase
		!	filter through an external program
		=	filter through 'equalprg' or C-indenting if empty
		gq	text formatting
		g?	ROT13 encoding
		>	shift right
		<	shift left
		zf	define a fold
		g@	call function set with the 'operatorfunc' option
		比如d4j，删除向下四行
	motion
		direction
			left right
				h		[count] characters to the left
				l		[count] characters to the left
				0		To the first character of the line. 
				^		To the first non-blank character of the line.
				$  		To the end of the line.
				g_		To the last non-blank character of the line and
				g0 		When lines wrap ('wrap' on): To the first character of the	screen line.
				g^		When lines wrap ('wrap' on): To the first non-blank	character of the screen line.
				g$		When lines wrap ('wrap' on): To the last character of the screen line and [count - 1] screen lines downward
				|		To screen column [count] in the current line.
				f{char}	To [count]'th occurrence of {char} to the right.  
				F{char}	To the [count]'th occurrence of {char} to the left.
				t{char}	Till before [count]'th occurrence of {char} to the right. 
				T{char}	Till after [count]'th occurrence of {char} to the left.
				;		Repeat latest f, t, F or T [count] times. 
				,		Repeat latest f, t, F or T in opposite direction[count] times.
			up down 
				k			[count] lines upward.  
				j			[count] lines downward.  
				gk			[count] display lines upward.  
				gj			[count] display lines downward.  
				-			[count] lines upward
				+			[count] lines downward
				_  			[count] - 1 lines downward
				G			Goto line [count], default last line
				gg			Goto line [count]
				:[range]	Set the cursor on the last line number in [range].
				{count}%	Go to {count} percentage in the file
				[count]go	Go to [count] byte in the buffer.
				:[range]go[to] [count] like go 

			count是移动命令前的数字，表示重复次数，以下同。
			比如4j，表示向下4行。
		Word motions
			w	[count] words forward.  |exclusive| motion.
			W	[count] WORDS forward.  |exclusive| motion.
			e	Forward to the end of word [count] |inclusive|.
			E	Forward to the end of WORD [count] |inclusive|.
			b	[count] words backward.  |exclusive| motion.
			B	[count] WORDS backward.  |exclusive| motion.
			ge	Backward to the end of word [count] |inclusive|.
			gE	Backward to the end of WORD [count] |inclusive|.
		Text object motions
			(	[count] sentences backward.  |exclusive| motion.
			)	[count] sentences forward.  |exclusive| motion.
			{	[count] paragraphs backward.  |exclusive| motion.
			}	[count] paragraphs forward.  |exclusive| motion.
			]]	[count] sections forward or to the next '{' in the
				first column.  When used after an operator, then also
				stops below a '}' in the first column.  |exclusive|
				Note that |exclusive-linewise| often applies.
			][	[count] sections forward or to the next '}' in the
				first column.  |exclusive|
				Note that |exclusive-linewise| often applies.
			[[	[count] sections backward or to the previous '{' in
				the first column.  |exclusive|
				Note that |exclusive-linewise| often applies.
			[]	[count] sections backward or to the previous '}' in
				the first column.  |exclusive|
				Note that |exclusive-linewise| often applies.
		 Text object selection
			This is a series of commands that can only be used while in
			Visual mode or after an operator.  The commands that start
			with "a" select "a"n object including white space, the
			commands starting with "i" select an "inner" object without
			white space, or just the white space.  Thus the "inner"
			commands always select less text than the "a" commands.

			aw		"a word", select [count] words (see |word|).
					Leading or trailing white space is included, but not
					counted.
					When used in Visual linewise mode "aw" switches to
					Visual characterwise mode.
			iw		"inner word", select [count] words (see |word|).
					White space between words is counted too.
					When used in Visual linewise mode "iw" switches to
					Visual characterwise mode.
			aW		"a WORD", select [count] WORDs (see |WORD|).
					Leading or trailing white space is included, but not
					counted.
					When used in Visual linewise mode "aW" switches to
					Visual characterwise mode.
			iW		"inner WORD", select [count] WORDs (see |WORD|).
					White space between words is counted too.
					When used in Visual linewise mode "iW" switches to
					Visual characterwise mode.
			as		"a sentence", select [count] sentences (see
					|sentence|).
					When used in Visual mode it is made characterwise.
			is		"inner sentence", select [count] sentences (see
					|sentence|).
					When used in Visual mode it is made characterwise.
			ap		"a paragraph", select [count] paragraphs (see
					|paragraph|).
					Exception: a blank line (only containing white space)
					is also a paragraph boundary.
					When used in Visual mode it is made linewise.
			ip		"inner paragraph", select [count] paragraphs (see
					|paragraph|).
					Exception: a blank line (only containing white space)
					is also a paragraph boundary.
					When used in Visual mode it is made linewise.
			a]					*v_a]* *v_a[* *a]* *a[*
			a[		"a [] block", select [count] '[' ']' blocks.  This
					goes backwards to the [count] unclosed '[', and finds
					the matching ']'.  The enclosed text is selected,
					including the '[' and ']'.
					When used in Visual mode it is made characterwise.
			i[		"inner [] block", select [count] '[' ']' blocks.  This
					goes backwards to the [count] unclosed '[', and finds
					the matching ']'.  The enclosed text is selected,
					excluding the '[' and ']'.
					When used in Visual mode it is made characterwise.
			a)
			a(
			ab		"a block", select [count] blocks, from "[count] [(" to
					the matching ')', including the '(' and ')' (see
					|[(|).  Does not include white space outside of the
					parenthesis.
					When used in Visual mode it is made characterwise.
			i)
			i(
			ib		"inner block", select [count] blocks, from "[count] [("
					to the matching ')', excluding the '(' and ')' (see
					|[(|).
					When used in Visual mode it is made characterwise.
			a>
			a<
					[count]'th unmatched '<' backwards to the matching
					'>', including the '<' and '>'.
					When used in Visual mode it is made characterwise.

			i>
			i<		"inner <> block", select [count] <> blocks, from
					the [count]'th unmatched '<' backwards to the matching
					'>', excluding the '<' and '>'.
					When used in Visual mode it is made characterwise.
			at		"a tag block", select [count] tag blocks, from the
					[count]'th unmatched "<aaa>" backwards to the matching
					"</aaa>", including the "<aaa>" and "</aaa>".
					See |tag-blocks| about the details.
					When used in Visual mode it is made characterwise.
			it		"inner tag block", select [count] tag blocks, from the
					[count]'th unmatched "<aaa>" backwards to the matching
					"</aaa>", excluding the "<aaa>" and "</aaa>".
					See |tag-blocks| about the details.
					When used in Visual mode it is made characterwise.
			a}
			a{
			aB		"a Block", select [count] Blocks, from "[count] [{" to
					the matching '}', including the '{' and '}' (see
					|[{|).
					When used in Visual mode it is made characterwise.
			i}
			i{
			iB		"inner Block", select [count] Blocks, from "[count] [{"
					to the matching '}', excluding the '{' and '}' (see
					|[{|).
					When used in Visual mode it is made characterwise.
			a"
			a'
			a`
					"a quoted string".  Selects the text from the previous
					quote until the next quote.  The 'quoteescape' option
					is used to skip escaped quotes.
					Only works within one line.
					When the cursor starts on a quote, Vim will figure out
					which quote pairs form a string by searching from the
					start of the line.
					Any trailing white space is included, unless there is
					none, then leading white space is included.
					When used in Visual mode it is made characterwise.
					Repeating this object in Visual mode another string is
					included.  A count is currently not used.
			i"
			i'
			i`
					Like a", a' and a`, but exclude the quotes and
					repeating won't extend the Visual selection.
					Special case: With a count of 2 the quotes are
					included, but no extra white space as with a"/a'/a`.
附录2 autocmd的事件
	see also by :h autocmd 

	Name			triggered by ~
		Reading
	*BufNewFile*		starting to edit a file that doesn't exist
	*BufReadPre*		starting to edit a new buffer, before reading the file
	*BufRead*			starting to edit a new buffer, after reading the file
	*BufReadPost*		starting to edit a new buffer, after reading the file
	*BufReadCmd|		before starting to edit a new buffer |Cmd-event*

	*FileReadPre*		before reading a file with a ":read" command
	*FileReadPost*		after reading a file with a ":read" command
	*FileReadCmd|		before reading a file with a ":read" command |Cmd-event*

	*FilterReadPre*		before reading a file from a filter command
	*FilterReadPost*	after reading a file from a filter command

	*StdinReadPre*		before reading from stdin into the buffer
	*StdinReadPost*		After reading from the stdin into the buffer
		Writing
	*BufWrite*			starting to write the whole buffer to a file
	*BufWritePre*		starting to write the whole buffer to a file
	*BufWritePost*		after writing the whole buffer to a file
	*BufWriteCmd|		before writing the whole buffer to a file |Cmd-event*

	*FileWritePre*		starting to write part of a buffer to a file
	*FileWritePost*		after writing part of a buffer to a file
	*FileWriteCmd|		before writing part of a buffer to a file |Cmd-event*

	*FileAppendPre*		starting to append to a file
	*FileAppendPost*	after appending to a file
	*FileAppendCmd|		before appending to a file |Cmd-event*

	*FilterWritePre*	starting to write a file for a filter command or diff
	*FilterWritePost*	after writing a file for a filter command or diff

		Buffers
	*BufAdd*		just after adding a buffer to the buffer list
	*BufCreate*		just after adding a buffer to the buffer list
	*BufDelete*		before deleting a buffer from the buffer list
	*BufWipeout*		before completely deleting a buffer

	*BufFilePre*		before changing the name of the current buffer
	*BufFilePost*		after changing the name of the current buffer

	*BufEnter*		after entering a buffer
	*BufLeave*		before leaving to another buffer
	*BufWinEnter*		after a buffer is displayed in a window
	*BufWinLeave*		before a buffer is removed from a window

	*BufUnload*		before unloading a buffer
	*BufHidden*		just after a buffer has become hidden
	*BufNew*		just after creating a new buffer

	*SwapExists*		detected an existing swap file
		Options
	*FileType*		when the 'filetype' option has been set
	*Syntax*		when the 'syntax' option has been set
	*EncodingChanged*	after the 'encoding' option has been changed
	*TermChanged*		after the value of 'term' has changed
	*OptionSet*		after setting any option

		Startup and exit
	*VimEnter*		after doing all the startup stuff
	*GUIEnter*		after starting the GUI successfully
	*GUIFailed*		after starting the GUI failed
	*TermResponse|		after the terminal response to |t_RV* is received

	*QuitPre*		when using `:quit`, before deciding whether to quit
	*VimLeavePre*		before exiting Vim, before writing the viminfo file
	*VimLeave*		before exiting Vim, after writing the viminfo file

		Various
	*FileChangedShell*	Vim notices that a file changed since editing started
	*FileChangedShellPost*	After handling a file changed since editing started
	*FileChangedRO*		before making the first change to a read-only file

	*ShellCmdPost*		after executing a shell command
	*ShellFilterPost*	after filtering with a shell command

	*CmdUndefined*		a user command is used but it isn't defined
	*FuncUndefined*		a user function is used but it isn't defined
	*SpellFileMissing*	a spell file is used but it can't be found
	*SourcePre*		before sourcing a Vim script
	*SourceCmd|		before sourcing a Vim script |Cmd-event*

	*VimResized*		after the Vim window size changed
	*FocusGained*		Vim got input focus
	*FocusLost*		Vim lost input focus
	*CursorHold*		the user doesn't press a key for a while
	*CursorHoldI*		the user doesn't press a key for a while in Insert mode
	*CursorMoved*		the cursor was moved in Normal mode
	*CursorMovedI*		the cursor was moved in Insert mode

	*WinNew*		after creating a new window
	*TabNew*		after creating a new tab page
	*TabClosed*		after closing a tab page
	*WinEnter*		after entering another window
	*WinLeave*		before leaving a window
	*TabEnter*		after entering another tab page
	*TabLeave*		before leaving a tab page
	*CmdwinEnter*		after entering the command-line window
	*CmdwinLeave*		before leaving the command-line window

	*InsertEnter*		starting Insert mode
	*InsertChange*		when typing <Insert> while in Insert or Replace mode
	*InsertLeave*		when leaving Insert mode
	*InsertCharPre*		when a character was typed in Insert mode, before
				inserting it
	*TextChanged*		after a change was made to the text in Normal mode
	*TextChangedI*		after a change was made to the text in Insert mode
	*TextYankPost*		after text is yanked or deleted

	*ColorScheme*		after loading a color scheme

	*RemoteReply*		a reply from a server Vim was received

	*QuickFixCmdPre*	before a quickfix command is run
	*QuickFixCmdPost*	after a quickfix command is run

	*SessionLoadPost*	after loading a session file

	*MenuPopup*		just before showing the popup menu
	*CompleteDone*		after Insert mode completion is done

	*User*			to be used in combination with ":doautocmd"

附录3 vim的函数
	see also by :h functon-list
	detail of function by :h eval.txt

String manipulation:					*string-functions*
	nr2char()		get a character by its ASCII value
	char2nr()		get ASCII value of a character
	str2nr()		convert a string to a Number
	str2float()		convert a string to a Float
	printf()		format a string according to % items
	escape()		escape characters in a string with a '\'
	shellescape()	escape a string for use with a shell command
	fnameescape()	escape a file name for use with a Vim command
	tr()			translate characters from one set to another
	strtrans()		translate a string to make it printable
	tolower()		turn a string to lowercase
	toupper()		turn a string to uppercase
	match()			position where a pattern matches in a string
	matchend()		position where a pattern match ends in a string
	matchstr()		match of a pattern in a string
	matchstrpos()	match and positions of a pattern in a string
	matchlist()		like matchstr() and also return submatches
	stridx()		first index of a short string in a long string
	strridx()		last index of a short string in a long string
	strlen()		length of a string in bytes
	strchars()		length of a string in characters
	strwidth()		size of string when displayed
	strdisplaywidth()	size of string when displayed, deals with tabs
	substitute()		substitute a pattern match with a string
	submatch()		get a specific match in ":s" and substitute()
	strpart()		get part of a string using byte index
	strcharpart()	get part of a string using char index
	strgetchar()	get character from a string using char index
	expand()		expand special keywords
	iconv()			convert text from one encoding to another
	byteidx()		byte index of a character in a string
	byteidxcomp()	like byteidx() but count composing characters
	repeat()		repeat a string multiple times
	eval()			evaluate a string expression
	execute()		execute an Ex command and get the output

List manipulation:					*list-functions*
	get()			get an item without error for wrong index
	len()			number of items in a List
	empty()			check if List is empty
	insert()		insert an item somewhere in a List
	add()			append an item to a List
	extend()		append a List to a List
	remove()		remove one or more items from a List
	copy()			make a shallow copy of a List
	deepcopy()		make a full copy of a List
	filter()		remove selected items from a List
	map()			change each List item
	sort()			sort a List
	reverse()		reverse the order of a List
	uniq()			remove copies of repeated adjacent items
	split()			split a String into a List
	join()			join List items into a String
	range()			return a List with a sequence of numbers
	string()		String representation of a List
	call()			call a function with List as arguments
	index()			index of a value in a List
	max()			maximum value in a List
	min()			minimum value in a List
	count()			count number of times a value appears in a List
	repeat()		repeat a List multiple times

Dictionary manipulation:				*dict-functions*
	get()			get an entry without an error for a wrong key
	len()			number of entries in a Dictionary
	has_key()		check whether a key appears in a Dictionary
	empty()			check if Dictionary is empty
	remove()		remove an entry from a Dictionary
	extend()		add entries from one Dictionary to another
	filter()		remove selected entries from a Dictionary
	map()			change each Dictionary entry
	keys()			get List of Dictionary keys
	values()		get List of Dictionary values
	items()			get List of Dictionary key-value pairs
	copy()			make a shallow copy of a Dictionary
	deepcopy()		make a full copy of a Dictionary
	string()		String representation of a Dictionary
	max()			maximum value in a Dictionary
	min()			minimum value in a Dictionary
	count()			count number of times a value appears

Floating point computation:				*float-functions*
	float2nr()		convert Float to Number
	abs()			absolute value (also works for Number)
	round()			round off
	ceil()			round up
	floor()			round down
	trunc()			remove value after decimal point
	fmod()			remainder of division
	exp()			exponential
	log()			natural logarithm (logarithm to base e)
	log10()			logarithm to base 10
	pow()			value of x to the exponent y
	sqrt()			square root
	sin()			sine
	cos()			cosine
	tan()			tangent
	asin()			arc sine
	acos()			arc cosine
	atan()			arc tangent
	atan2()			arc tangent
	sinh()			hyperbolic sine
	cosh()			hyperbolic cosine
	tanh()			hyperbolic tangent
	isnan()			check for not a number

Other computation:					*bitwise-function*
	and()			bitwise AND
	invert()		bitwise invert
	or()			bitwise OR
	xor()			bitwise XOR
	sha256()		SHA-256 hash

Variables:						*var-functions*
	type()			type of a variable
	islocked()		check if a variable is locked
	funcref()		get a Funcref for a function reference
	function()		get a Funcref for a function name
	getbufvar()		get a variable value from a specific buffer
	setbufvar()		set a variable in a specific buffer
	getwinvar()		get a variable from specific window
	gettabvar()		get a variable from specific tab page
	gettabwinvar()	get a variable from specific window & tab page
	setwinvar()		set a variable in a specific window
	settabvar()		set a variable in a specific tab page
	settabwinvar()	set a variable in a specific window & tab page
	garbagecollect()	possibly free memory

Cursor and mark position:		*cursor-functions* *mark-functions*
	col()			column number of the cursor or a mark
	virtcol()		screen column of the cursor or a mark
	line()			line number of the cursor or mark
	wincol()		window column number of the cursor
	winline()		window line number of the cursor
	cursor()		position the cursor at a line/column
	screencol()		get screen column of the cursor
	screenrow()		get screen row of the cursor
	getcurpos()		get position of the cursor
	getpos()		get position of cursor, mark, etc.
	setpos()		set position of cursor, mark, etc.
	byte2line()		get line number at a specific byte count
	line2byte()		byte count at a specific line
	diff_filler()	get the number of filler lines above a line
	screenattr()	get attribute at a screen line/row
	screenchar()	get character code at a screen line/row

Working with text in the current buffer:		*text-functions*
	getline()		get a line or list of lines from the buffer
	setline()		replace a line in the buffer
	append()		append line or list of lines in the buffer
	indent()		indent of a specific line
	cindent()		indent according to C indenting
	lispindent()	indent according to Lisp indenting
	nextnonblank()	find next non-blank line
	prevnonblank()	find previous non-blank line
	search()		find a match for a pattern
	searchpos()		find a match for a pattern
	searchpair()	find the other end of a start/skip/end
	searchpairpos()	find the other end of a start/skip/end
	searchdecl()	search for the declaration of a name
	getcharsearch()	return character search information
	setcharsearch()	set character search information

					*system-functions* *file-functions*
System functions and manipulation of files:
	glob()			expand wildcards
	globpath()		expand wildcards in a number of directories
	glob2regpat()	convert a glob pattern into a search pattern
	findfile()		find a file in a list of directories
	finddir()		find a directory in a list of directories
	resolve()		find out where a shortcut points to
	fnamemodify()	modify a file name
	pathshorten()	shorten directory names in a path
	simplify()		simplify a path without changing its meaning
	executable()	check if an executable program exists
	exepath()		full path of an executable program
	filereadable()	check if a file can be read
	filewritable()	check if a file can be written to
	getfperm()		get the permissions of a file
	setfperm()		set the permissions of a file
	getftype()		get the kind of a file
	isdirectory()	check if a directory exists
	getfsize()		get the size of a file
	getcwd()		get the current working directory
	haslocaldir()	check if current window used |:lcd|
	tempname()		get the name of a temporary file
	mkdir()			create a new directory
	delete()		delete a file
	rename()		rename a file
	system()		get the result of a shell command as a string
	systemlist()	get the result of a shell command as a list
	hostname()		name of the system
	readfile()		read a file into a List of lines
	writefile()		write a List of lines into a file

Date and Time:				*date-functions* *time-functions*
	getftime()		get last modification time of a file
	localtime()		get current time in seconds
	strftime()		convert time to a string
	reltime()		get the current or elapsed time accurately
	reltimestr()	convert reltime() result to a string
	reltimefloat()	convert reltime() result to a Float

			*buffer-functions* *window-functions* *arg-functions*
Buffers, windows and the argument list:
	argc()			number of entries in the argument list
	argidx()		current position in the argument list
	arglistid()		get id of the argument list
	argv()			get one entry from the argument list
	bufexists()		check if a buffer exists
	buflisted()		check if a buffer exists and is listed
	bufloaded()		check if a buffer exists and is loaded
	bufname()		get the name of a specific buffer
	bufnr()			get the buffer number of a specific buffer
	tabpagebuflist()	return List of buffers in a tab page
	tabpagenr()		get the number of a tab page
	tabpagewinnr()	like winnr() for a specified tab page
	winnr()			get the window number for the current window
	bufwinid()		get the window ID of a specific buffer
	bufwinnr()		get the window number of a specific buffer
	winbufnr()		get the buffer number of a specific window
	getbufline()	get a list of lines from the specified buffer
	win_findbuf()	find windows containing a buffer
	win_getid()		get window ID of a window
	win_gotoid()	go to window with ID
	win_id2tabwin()	get tab and window nr from window ID
	win_id2win()	get window nr from window ID
	getbufinfo()	get a list with buffer information
	gettabinfo()	get a list with tab page information
	getwininfo()	get a list with window information

Command line:					*command-line-functions*
	getcmdline()	get the current command line
	getcmdpos()		get position of the cursor in the command line
	setcmdpos()		set position of the cursor in the command line
	getcmdtype()	return the current command-line type
	getcmdwintype()	return the current command-line window type
	getcompletion()	list of command-line completion matches

Quickfix and location lists:			*quickfix-functions*
	getqflist()		list of quickfix errors
	setqflist()		modify a quickfix list
	getloclist()	list of location list items
	setloclist()	modify a location list

Insert mode completion:				*completion-functions*
	complete()		set found matches
	complete_add()		add to found matches
	complete_check()	check if completion should be aborted
	pumvisible()		check if the popup menu is displayed

Folding:					*folding-functions*
	foldclosed()	check for a closed fold at a specific line
	foldclosedend()	like foldclosed() but return the last line
	foldlevel()		check for the fold level at a specific line
	foldtext()		generate the line displayed for a closed fold
	foldtextresult()	get the text displayed for a closed fold

Syntax and highlighting:	  *syntax-functions* *highlighting-functions*
	clearmatches()		clear all matches defined by |matchadd()| and
				the |:match| commands
	getmatches()	get all matches defined by |matchadd()| and
				the |:match| commands
	hlexists()		check if a highlight group exists
	hlID()			get ID of a highlight group
	synID()			get syntax ID at a specific position
	synIDattr()		get a specific attribute of a syntax ID
	synIDtrans()	get translated syntax ID
	synstack()		get list of syntax IDs at a specific position
	synconcealed()	get info about concealing
	diff_hlID()		get highlight ID for diff mode at a position
	matchadd()		define a pattern to highlight (a "match")
	matchaddpos()	define a list of positions to highlight
	matcharg()		get info about |:match| arguments
	matchdelete()	delete a match defined by |matchadd()| or a
				|:match| command
	setmatches()		restore a list of matches saved by
				|getmatches()|

Spelling:					*spell-functions*
	spellbadword()	locate badly spelled word at or after cursor
	spellsuggest()	return suggested spelling corrections
	soundfold()		return the sound-a-like equivalent of a word

History:					*history-functions*
	histadd()		add an item to a history
	histdel()		delete an item from a history
	histget()		get an item from a history
	histnr()		get highest index of a history list

Interactive:					*interactive-functions*
	browse()		put up a file requester
	browsedir()		put up a directory requester
	confirm()		let the user make a choice
	getchar()		get a character from the user
	getcharmod()	get modifiers for the last typed character
	feedkeys()		put characters in the typeahead queue
	input()			get a line from the user
	inputlist()		let the user pick an entry from a list
	inputsecret()	get a line from the user without showing it
	inputdialog()	get a line from the user in a dialog
	inputsave()		save and clear typeahead
	inputrestore()		restore typeahead

GUI:						*gui-functions*
	getfontname()	get name of current font being used
	getwinposx()	X position of the GUI Vim window
	getwinposy()	Y position of the GUI Vim window
	balloon_show()	set the balloon content
	balloon_split()	split a message for a balloon

Vim server:					*server-functions*
	serverlist()	return the list of server names
	remote_startserver()	run a server
	remote_send()	send command characters to a Vim server
	remote_expr()	evaluate an expression in a Vim server
	server2client()	send a reply to a client of a Vim server
	remote_peek()	check if there is a reply from a Vim server
	remote_read()	read a reply from a Vim server
	foreground()	move the Vim window to the foreground
	remote_foreground()	move the Vim server window to the foreground

Window size and position:			*window-size-functions*
	winheight()		get height of a specific window
	winwidth()		get width of a specific window
	win_screenpos()	get screen position of a window
	winrestcmd()	return command to restore window sizes
	winsaveview()	get view of current window
	winrestview()	restore saved view of current window

Mappings:				    *mapping-functions*
	hasmapto()		check if a mapping exists
	mapcheck()		check if a matching mapping exists
	maparg()		get rhs of a mapping
	wildmenumode()	check if the wildmode is active

Testing:				    *test-functions*
	assert_equal()		assert that two expressions values are equal
	assert_notequal()	assert that two expressions values are not equal
	assert_inrange()	assert that an expression is inside a range
	assert_match()		assert that a pattern matches the value
	assert_notmatch()	assert that a pattern does not match the value
	assert_false()		assert that an expression is false
	assert_true()		assert that an expression is true
	assert_exception()	assert that a command throws an exception
	assert_fails()		assert that a function call fails
	assert_report()		report a test failure
	test_alloc_fail()	make memory allocation fail
	test_autochdir()	enable 'autochdir' during startup
	test_override()		test with Vim internal overrides
	test_garbagecollect_now()   free memory right now
	test_ignore_error()	ignore a specific error message
	test_null_channel()	return a null Channel
	test_null_dict()	return a null Dict
	test_null_job()		return a null Job
	test_null_list()	return a null List
	test_null_partial()	return a null Partial function
	test_null_string()	return a null String
	test_settime()		set the time Vim uses internally

Inter-process communication:		    *channel-functions*
	ch_canread()		check if there is something to read
	ch_open()		open a channel
	ch_close()		close a channel
	ch_close_in()	close the in part of a channel
	ch_read()		read a message from a channel
	ch_readraw()	read a raw message from a channel
	ch_sendexpr()	send a JSON message over a channel
	ch_sendraw()	send a raw message over a channel
	ch_evalexpr()	evaluates an expression over channel
	ch_evalraw()	evaluates a raw string over channel
	ch_status()		get status of a channel
	ch_getbufnr()	get the buffer number of a channel
	ch_getjob()		get the job associated with a channel
	ch_info()		get channel information
	ch_log()		write a message in the channel log file
	ch_logfile()	set the channel log file
	ch_setoptions()	set the options for a channel
	json_encode()	encode an expression to a JSON string
	json_decode()	decode a JSON string to Vim types
	js_encode()		encode an expression to a JSON string
	js_decode()		decode a JSON string to Vim types

Jobs:		    			        *job-functions*
	job_start()		start a job
	job_stop()		stop a job
	job_status()		get the status of a job
	job_getchannel()	get the channel used by a job
	job_info()		get information about a job
	job_setoptions()	set options for a job

Terminal window:				*terminal-functions*
	term_start()	open a terminal window and run a job
	term_list()		get the list of terminal buffers
	term_sendkeys()	send keystrokes to a terminal
	term_wait()		wait for screen to be updated
	term_getjob()		get the job associated with a terminal
	term_scrape()		get row of a terminal screen
	term_getline()		get a line of text from a terminal
	term_getattr()		get the value of attribute {what}
	term_getcursor()	get the cursor position of a terminal
	term_getscrolled()	get the scroll count of a terminal
	term_getaltscreen()	get the alternate screen flag
	term_getsize()		get the size of a terminal
	term_getstatus()	get the status of a terminal
	term_gettitle()		get the title of a terminal
	term_gettty()		get the tty name of a terminal

Timers:						*timer-functions*
	timer_start()		create a timer
	timer_pause()		pause or unpause a timer
	timer_stop()		stop a timer
	timer_stopall()		stop all timers
	timer_info()		get information about timers

Various:					*various-functions*
	mode()			get current editing mode
	visualmode()	last visual mode used
	exists()		check if a variable, function, etc. exists
	has()			check if a feature is supported in Vim
	changenr()		return number of most recent change
	cscope_connection()	check if a cscope connection exists
	did_filetype()	check if a FileType autocommand was used
	eventhandler()	check if invoked by an event handler
	getpid()		get process ID of Vim

	libcall()		call a function in an external library
	libcallnr()		idem, returning a number

	undofile()		get the name of the undo file
	undotree()		return the state of the undo tree

	getreg()		get contents of a register
	getregtype()	get type of a register
	setreg()		set contents and type of a register

	shiftwidth()	effective value of 'shiftwidth'

	wordcount()		get byte/word/char count of buffer

	taglist()		get list of matching tags
	tagfiles()		get a list of tags files

	luaeval()		evaluate Lua expression
	mzeval()		evaluate |MzScheme| expression
	perleval()		evaluate Perl expression (|+perl|)
	py3eval()		evaluate Python expression (|+python3|)
	pyeval()		evaluate Python expression (|+python|)
	pyxeval()		evaluate |python_x| expression

附录 4 pattern 
	\s	whitespace character: <Space> and <Tab>		*/\s*
	\S	non-whitespace character; opposite of \s	*/\S*
	\d	digit:				[0-9]		*/\d*
	\D	non-digit:			[^0-9]		*/\D*
	\x	hex digit:			[0-9A-Fa-f]	*/\x*
	\X	non-hex digit:			[^0-9A-Fa-f]	*/\X*
	\o	octal digit:			[0-7]		*/\o*
	\O	non-octal digit:		[^0-7]		*/\O*
	\w	word character:			[0-9A-Za-z_]	*/\w*
	\W	non-word character:		[^0-9A-Za-z_]	*/\W*
	\h	head of word character:		[A-Za-z_]	*/\h*
	\H	non-head of word character:	[^A-Za-z_]	*/\H*
	\a	alphabetic character:		[A-Za-z]	*/\a*
	\A	non-alphabetic character:	[^A-Za-z]	*/\A*
	\l	lowercase character:		[a-z]		*/\l*
	\L	non-lowercase character:	[^a-z]		*/\L*
	\u	uppercase character:		[A-Z]		*/\u*
	\U	non-uppercase character:	[^A-Z]		*/\U*

		NOTE: Using the atom is faster than the [] form.

		NOTE: 'ignorecase', "\c" and "\C" are not used by character classes.

				*/\_* *E63* */\_i* */\_I* */\_k* */\_K* */\_f* */\_F*
				*/\_p* */\_P* */\_s* */\_S* */\_d* */\_D* */\_x* */\_X*
				*/\_o* */\_O* */\_w* */\_W* */\_h* */\_H* */\_a* */\_A*
				*/\_l* */\_L* */\_u* */\_U*
	\_x	Where "x" is any of the characters above: The character class with
		end-of-line added
	(end of character classes)
	\e	matches <Esc>					*/\e*
	\t	matches <Tab>					*/\t*
	\r	matches <CR>					*/\r*
	\b	matches <BS>					*/\b*
	\n	matches an end-of-line				*/\n*
		When matching in a string instead of buffer text a literal newline
		character is matched.

// vim:tw=72
