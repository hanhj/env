第一章 帮助
	:help key	(h)	显示帮助。如果带key，则显示key的帮助。
	:options	显示选项帮助
	在vim中执行shell命令需要在命令前加上惊叹号
	:!command
	$vimruntime	vim的环境变量/usr/share/vim/vim73
	:scriptnames	显示脚本文件
	%	跳转到匹配的(){}[]处。在编程的时候比较快捷。

第二章 移动
	1) 关于vim的状态：
		刚进入vim的时候，vim处于普通(normal)状态，此时只能用键盘上的上下左右或特殊键的组合来移动光标。不能编辑文本。
		在normal状态下，键入i,a,o或I,A,O键，vim将进入编辑（edit) 状态，此时可以键入字符。在edit状态按ESC键，将退出edit状态，恢复到normal状态。
		在normal状态下，键入:vim将进入命令(command)状态。此时光标位于最下一行，并有提示符:。此时可以输入命令。在命令状态中按ESC键，将退出command状态，恢复到normal状态。
		在以下的描述中如果英文单词前面有:表示是在命令状态下。比如:set,表示在命令状态下输入set命令。
 		如果名词后面带一个括号，则括号中的字符作为前面名词的缩略。比如number(nu),表示可以用nu来代替number。
		如果有xx->xxx，表示助记符，将xx理解成xxx。
	2) 一般的移动
		在normal状态下
		h	左移
		l	右移
		j	下移
		k	上移
		w	向后移动到下一个单词的首位置	w->next word
		b	向前移动到前一个单词的首位置	b->back word
		e	向后移动到下一个单词的尾位置	e->end
			如果是W,B,E大写字母则认为单词是以空格,)等作为分隔。这样移动将更快。
		ge	向前移动到前一个单词的尾位置	g->go
		以上字母前面都可以加上数字，以代表移动多少数量。比如：
		3k	表示上移3行。

		gg	:跳转到开始
		G	：跳转到结尾
		xgg	:跳转到x行
		xG	:跳到x行
		0	:跳转到本行开始
		$	:跳转到本行的结束。
		fx	:跳转到字符x处,x是任意字符	f->find
		Fx	:向左跳转到字符x处

		记住常用的跳转命令：j,l,h,k,g
		
		ctrl-f	向前翻页	f->foward
		ctrl-b	向后翻页	b->backward
		zt	将当前光标所在位置提到屏幕顶行	z想象成一个折叠的纸，t->top
		zb	将当前光标所在位置移到屏幕底行。b->bottom
		zz	将当前光标所在位置移到屏幕中央。
		ctrl-]	将以光标所在处的单词为关键字，跳转到其相关联的地方（称为tag标记) 
		ctrl-o或ctrl-t从跳转处返回。
		:xx	直接跳转到xx行
		:set number(nu)		显示行号
		:set nonumber(nonu)	不显示行号
	3) 用标记跳转：
		mx	：设置标记。在noraml状态下。x是任意小写字母。
		`x	：跳转到标记x处。在noraml状态下。`是键盘左上角的反引号,x是刚才所做的标记字母。
			比如将光标移动到某行，在noraml状态下键入ma,然后转到其他地方，再敲入`a则可以跳回到刚才做标记的地方。
		注意用小写字母是在本文档中设置标记，离开本文档该标记就消失。如果用大写字母做标记，则是全局的,可以在多个文件中跳转。
		做标记也可用%，比如在文档的%50处做标记，可以在normal模式下输入50%ms。
		几个特殊标记：
		 	`表示上次跳转的地方，``就可以在两次跳转之间来回跳了。
			.表示最后修改的地方.
			"表示上次编辑该文件，最后光标停留的地方。
			[表示最后修改开始的位置。
			]表示最后修改结束的位置。
		:marks	显示标记
	4) 搜索字符串
		/str 搜索str，如果找到，会将str反显。此时按n将跳转到下一个，shift-n跳转的前一个。
		/str实际上是字符串匹配，可以用正则表达式中的符号。比如精确匹配单词the，而不是somethere。可以用/\<the\>,这里\是转义符，><表示定位在结束还是开头。关于正则表达式可以参见《linux_env_study.txt》和《linux_env.txt》中的相关内容。
		:set ignorecase		(ic)	搜索时忽略大小写，这是默认的。
		:set noignorecase	(noic)	不忽略大小写，即大小写敏感。
		如果不想输入太多的字符，可以将光标定位到某个单词，然后输入*，此时vim会自动提取光标所在处的单词向后进行搜索。输入#，将向前跳转。
		:set incsearch		(is)	可以在输入查找字符串的时候就开始匹配。
		:set noincsearch	(nois)	可以取消上面设置。
		:set wrapscan		(ws)	搜索时回转
		:set nowrapscan		(nows)	取消搜索回转

第三章 文本编辑
	1) 基本命令
		a,A	进入编辑模式，并将光标向后移动1位
		i,I	进入编辑模式，光标不移动。
		o	进入编辑模式，在当前行后插入一行。
		O	进入编辑模式，在当前行前插入一行。
		d{motion}	删除motion移动到的字符。
			motion是移动单词，比如w:next word,b:back word,l,h,j,k等。
			比如：
			dw	删除后一个单词
			db	删除前一个单词
			dj	删除下一行
			d4j	删除下面4行
			dk	删除上一行

		dfx	删除从当前光标到所找到的第一个字符x之间的字符，包括x。比如dfa，表示删除从当前光标到第一个字母a之间的内容。
			dFx：向前删除
		d$	删除当前光标到行尾的字符。$表示行尾。
		D	删除从当前光标行尾的字符。同d$
		dd	删除一行
		x	删除当前光标下的字符。相当于dl	l表示右移
		X	删除当前光标左边的字符。相当于dh	h表示左移
		c	与d类似，但是删除后将进入插入模式
		cl	与dl类似，但是删除后将进入插入模式。快捷键是s
		cc	与dd类似，并进入插入模式。快键键是S
		y{motion}	根据motion复制内容	y->yank 拉
			比如：
			yw	:复制当前光标到下一个单词的内容	
			yb	：复制当前光标到前一个单词的内容
			yj	：复制当前行到下一行的内容
			yk	：复制当前行到前一行的内容
		yy	复制一行	
		Y	复制多行，同yy
		p	粘贴内容到当前光标后
		P	粘贴内容到当前光标前
		以上命令前都可以加上数字以表示重复次数。比如3dd表示删除从当前行删除3行。
		记住常用的编辑命令：a,i,o,d,y,x,p

		visual模式：可视化模式。有三种visual模式。
		V	进入行visual模式。行visual模式是以整行作为处理单位。
		v	进入visual模式。visual模式与行visual模式所不同的是开始位置从第一个单词开始。
		ctrl-v进入列块的visual模式

		visual模式下，先用光标选择块，然后：
			I	insert，在选择的块插入后面敲入的字符
			c	change，删除选择的块，然后进入编辑模式,用敲入的字符代替块。
			C	删除块到行尾的字符，后面同c
			r	replace,将块用一个字符来替换。
			>	右移块
			<	左移块
			J	将块中的内容连接成一行
		
		:[pos] read(r) file	:在pos处下一行，插入文件。没有pos默认是当前位置。
		:[range] write(w) file	:将range范围内的内容写入文件。

第四章 定制vim	
	1) 使用vim自带选项。
		vim的选项很多，通过定制可以更方便的使用vim.
		我们可以手动定制vim的一些选项，比如 
		:set(se) number(nu)	显示行号 
		:se list		显示控制字符
		:se filetype	显示当前文件的文件类型。
			文件类型自动检测：filetype on.文件类型检测是用$vimruntime/filetype.vim中来检测，用:filetype 可以显示当前文件自动检测的情况。
		vi中的选项可以是：
			布尔型变量：可以用:set xx 来打开，:set noxx来关闭。比如：
				:se nu		打开行号显示
				:se nonu	关闭行号显示
			参数型选项：
				:se xx=xxx	设置xx选项为xxx
				:se xx?,或
				:se xx		显示当前值
				:se xx&	恢复xx为默认值
		:se		查看当前的选项情况
		关于选项这里不用赘述，具体配置项可以参见options(用:options)

		.	重复命令：
			在vim中会记录所敲入的任何命令，在normal状态下，键入.可以执行最后一次所执行的命令。
	2) 添加一个plugin。
		vim支持插件，以增强vim的功能。（用:scriptnames(scr)可以显示当前装入的脚本文件) 
		vim的安装目录一般在 /usr/share/vim/vimxx(xx是当前vim的版本号)。在vim中vim的安装位置保存在$vimruntime变量中。在此目录下面有:
		macros:		定义了全局配置；
		/ftplugin	定义不同文件类型的插件。
		将macros或ftplugin目录下需要的文件，拷贝到~/.vim/plugin目录下。就可以支持这些插件了。插件的文件名后缀一般是vim
		将上述目录中的相关插件的txt文件拷贝到~/.vim/doc目录下，然后再vim中执行:helptags ~/.vim/doc就可以在帮助文件里支持这些插件了。
	3) 关于颜色
		:syntax	enable可以打开语法高亮。
		:colorscheme (colo)	设置配色方案
			配色方案在 /usr/share/vim/vimxx/colors/目录下 

第五章 多文件编辑：
	1) 打开多文件:
		方法1:在控制台时,输入多个文件名。
			如：vim a b c
		方法2：在命令模式中输入:edit(e) 文件名。
			:vim e a 读入文件a
			:e!	丢弃当前文件修改，重新读入文件。利用这一点，可以在当当前文件别其他程序修改后，重新读入文件。
		方法3：在命令模式中输入：args 文件名。相当于启动vim 给其多个参数。
		:args a b c
	2) 切换文件：
		:next(n)	切换到下一个文件
		:previous(prev)	切换到前一个文件
		ctrl-^	在当前文件与执行了切换动作的两个文件之间来回切换。
	3) 保存文件：
		:w	:保存当前缓冲区到进入时打开的文件。
		:w filename ：保存当前缓冲区到文件filename中。缓冲区没变，即当前缓冲区针对的还是原来打开的文件，如果修改了没有保存，缓冲区的标志仍然是没有保存。此时在vim状态栏中所指示的文件名依然是原来的文件。
		:saveas (sav) filename:文件改名并保存。将当前缓冲区名改为filename，并保存。
		% 代表当前编辑的文件。
	4) 移动到窗口：
		将光标移动到窗口
		ctrl-w  h	左边
		ctrl-w	j	下边
		ctrl-w	k	上边
		ctrl-w	l	右边
	5) 窗口移动
		将当前窗口移动到
		ctrl-w  H	左边
		ctrl-w	J	下边
		ctrl-w	K	上边
		ctrl-w	L	右边
		:files	在状态栏中显示当前编辑的文件
	6) 关于全部窗口的操作：
		:wall(wa)	保存所有窗口中文件
		:qall(qa)	退出所有窗口
	7) 比较两个文件
		vimdiff a b	在bash环境中
		在进入vim后
		:diffsplit(diffs) file :前面可以加上vertical(vert) 表示垂直
		:diffpatch(diffp) patchfile :对当前文件打上patch

第六章 分隔窗口
	1) 基本命令
		:split(sp)[file]	水平建立一个窗口。如果不带file，则将当前文件分隔成水平两个部分。如果带file，则在新窗口打开文件file
		:vsplit(vsp)[file] 垂直分隔
		:new[file]	水平开一个新窗口，并建立一个新文件缓冲区。
		:vnew[file]	垂直开一个新窗口，并建立一个新文件缓冲区。
		:close(clo)	关闭当前窗口
		:only(on)	关闭除当前窗口的其他窗口。 
第七章 大刀阔斧
	本章介绍一些影响范围较大的命令
	1) 宏命令
		与word中将操作动作记录下来，以后可以调用这些动作序列功能类似，在vim中也有类似的动作记录。
		qx	:启动宏记录。在normal状态下敲入q然后再敲入一个字母，就启动了一个动作序列记录。x为小写字母a-z，表示该宏的名字。
			然后就像正常编辑一样进行操作，最后敲入q退出宏记录状态。
		@x	:执行宏。在想要执行宏的行，在normal状态下输入@x将执行此宏。@@表示重复执行前一次所执行的宏（不能用.）。
		"xp	:显示宏。在任意空白行，在normal状态下输入"xp，x是宏名。
			命令的解释："表示对寄存器操作，x是要操作的宏，p是paste。
			实际上宏命令与d，y操作一样，也是将内容保存到一个寄存器中。
			这里有必要再对我们熟悉的d，y操作进一步学习。实际上d，y操作的前面除了可以加上数字以表示重复外，还有一个["x]选项，意思是将d或y的内容保存到某个有名字的寄存器中。
			所以，完整的d或y操作命令应当是:["x]y{motion},表示根据motion将内容复制到寄存器x中。比如：
			"ayy	表示复制当前行内容到a寄存器中。只不过平时为了方便，我们不加上前面的寄存器选项，此时vim将内容保存到默认的寄存器中。
		"xy$:修改宏。如果所记录的宏不正确，又不想重新输一遍，则可以在上面所显示的宏中进行修改，然后退出到noraml状态下，用此命令进行保存。
		:register(reg) 显示寄存器内容
		例子：想将以下代码中的return 0;用外部文件a来替换。
			fun1(){
				return 0;
			}
			fun2(){
				return 0;
			}
			fun3(){
				return 0;
			}
			a文件中的内容为：
				int len=0;
				int offset=0;
				len=sizeof(p);
			在normal状态下输入qa，然后键入以下内容：
			^jddk:read ajjjkI				4j^
			输入完用q结束。
			上面的一些控制字符是在命令输入时产生的。
			然后将光标放到第一行，执行3@a,就可以了。
	2) 替换
		:[range]substitute(s)/from/to/[flags]
			在指定范围内用to字串替换from字串。
			from一般是正则表达式。
			range 范围:
				可以用数字，特殊字符，或正则表达式
				数字：
					a,b	起始a，终点b
					没有指定a，b则是当前行
				特殊字符：
					$	最后一行
					%	全文
				标记：
					`a,`b
				正则表达式：
					/expr1/,/expr2/
			from:匹配字串
				可以用正则表达式 
				在正则表达式中的命令分隔符可以改变。（通常是为了显示明了）
				比如在正文中搜索fun1,到fun2之间的，将return 0 替换成return 1
				/fun1/,/fun2/s=return 0=return 1=
	3) 全局命令
		:[range]global(g)/patten/command/flag
			与substitute命令所不同的是后面可以是命令。
			需要注意的是命令是在命令模式下输入的命令，而不是normal状态下的命令。
	4）visual mode模式
		visual mode模式可以通过光标来选择一块区域。
		v	进入visual mode
		V	进入行visual mode
		CTRL-V	进入块visual mode 
		多重复制
				在visual模式下，可以将多个地方的内容合在一起进行复制：
				先进入visual模式，然后选择文本，"xy x是任意小写字母，此时vim提示复制了几行内容,并退出visual模式。
				然后到另外一处用visual模式选择文本，此时用"Xy进行复制，X是刚才字母的大写字母。此时在x寄存器中就追加了刚才复制的文本。然后用p就可以黏贴了。
				实际上在vim中的寄存器用大写，表示追加。
	5）格式化文本
		:se textwidth=xx	设置每行的列数
		gqap	:gq表示整理文本，ap表示一段文本
	6) 改变大小写
		gu{motion}	小写	例如guw
		gU{motion}	大写
		g~{motion}	大小写反转	g~~
	7) 外部程序
		[range]!command	:
			range是执行范围
			!表示要执行外部程序，
			command是外部程序。
			例如，将当前行下三行排序。执行如下命令：
			在normal状态执行：!3j,此时命令行会出现:.,.+3!,输入sort就可以了。			在visual模式下，也可以执行。先选定范围，再输入!,此时vim会自动添加range部分,然后输入sort命令。
	8） 部分写入文件
		:[range]w file 
		:[range]w >>file	追加
第八章 交换文件
	为了防止文件丢失，vim会每4秒不连续键入，或敲入200个字符后同步磁盘。
	:se updatetime?
	:se updatecount?来查看
	一旦发生错误，可以通过交换文件来恢复文本。
	vim -r file		:shell下，-r 表示恢复
	vim -r			:查看交换文件的位置。
第九章 奇技淫巧
	多文件替换：
		可以用宏来做。比如替换所有cpp中的return 0;为retnurn 1;
		vim *.cpp
		qq
		%s/return 0;/return 1;/ge	g表示替换一行中所有匹配字符，e表示即使出错也继续
		:wnext
		q
		999@q
	排序：
		如果想对某一段文本进行排序，可以用如下命令：
		:range!sort
		or
		:.,/^$/-1!sort	.代表当前行，/^$/代表空行,-1代表空行的前一行，即从当前行到空行之前一行进行排序,!sort调用外部sort程序。
	逆序：
		将所有文本逆序排列
		:g/^/m 0	g表示global，^表示匹配一行，m表示move,0表示移动到首行之前。
			[range]move(m){pos}
	统计字数：
		g<ctrl-g>	会在状态栏中显示当前文件的统计信息。
	调用man：
		:source $VIMRUNTIME/ftplugin/man.vim 
		:Man xx 
	使用grep
		vim内置grep，其实调用了外部grep程序。
		:grep something files 
		此时会打开第一个匹配文件。

第十章 命令行
	在命令行窗口可以：
		tab	:自动补齐
	历史命令：
		vim的历史命令有四个记录：
			冒号命令记录，/,?的搜索记录
		冒号命令记录：
			如果记得命令的开头几个字母，在:后输入字符，然后用上下键进行查找。ctrl-p同上键，ctrl-n同下键。prev，next。ctrl-u取消，此时可以重新输入命令。
		:his /	查看/查找记录
		:his ?	查看？查找记录
		q:		打开冒号命令记录。此时光标在命令记录窗口中，处于normal状态，通过i，进入编辑状态，编辑好了按回车就可以执行该命令。

第十一章 进退之间
	记住编辑信息
		正如前面几章所描述的：
			vim可以做标记marks，用`来跳转。
				用mx做标记，用:marks查看
			vim通过寄存器可以记录宏，复制内容等
				用qx，"xy{motion},来标记;用:reg查看
			vim可以记住命令，用his来调出
				:his 
		以上这些内容存在于一个叫viminfo的文件中.
		可以将viminfo保存到一个文件中，以共享
		:wviminfo! file 
		:rviminfo file 
		默认的时候是.viminfo文件,保存在用户的己目录下。是一个全局属性。
	保存会话状态：
		会话状态保存当前的全局变量，窗口位置，选项等。这样就可以在上一次停止的位置继续进行。是一个局部属性。
		:mksession file 
		:source file 
		或vim -S  file
		如果不带file，则默认是在当前目录建立一个Session.vim文件
		session和viminfo是不同的，viminfo自动建立，session如果需要可以手动建立。
	窗口状态：是一个局部属性。
		如果想记住窗口的分布状态可用:mkview,然后用:loadview(lo),来恢复。
		如果有不同类型的窗口可用：mkview number,然后用：lo number来恢复。
		或者用:mkview file ;:source file来恢复 
	模式行：
		对于某些文件，需要一些特别设置，而又不希望是全局的设置（直白的说就是希望改变.vimrc文件中的设置），这些设置不需要每次手动改变。vim提供的方法是在该文件中放入这些配置。语法是：any text vim:set {option}={value}...
		any text的意思是任意文本
		比如 // vim:set textwidth=72
		在vim之前必须有一个空格，vim识别vim:关键字

第十二章 文件查找
	文件浏览器：
		:edit .	可以以当前目录，打开一个文件浏览器。这时可以用上下键选择其中的文件enter打开该文件。
		也可以
		s：排序，r：逆向排序
		o：打开新窗口
		p：预览文件
		R：重命名
		D：删除文件
		i: 显示大小日期信息（此时，将光标移动到日期或大小栏，按s，r可以按照大小或日期排序）
		c: 将当前目录改变到光标所在文件的目录。
		
		ctrl-o回退到原窗口









第二十八章 折行
	对于一个结构化文本，可能由多章构成，每章有多段，每段有多节。
	对于一个源程序文档，可能由不同的缩进表示代码的层次。
	通过折行，可以将同一章，段，节或层次的内容折叠起来，就像将一张纸折叠起来一样，在折叠处显示折叠起来的内容的首行内容，这样更容易看清文档的结构。
	折行的操作都是在normal状态下执行。
	1) 手动折行
		手动折行就是手动定义折行的内容。
		zfap ：折行定义。
			z可以理解为折叠，f->flag，zf表示定义折叠，ap表示以下文本内容。
			在vim（或其他很多文本处理程序）中将没有分行的文本作为一段连续的文本，作为一段，即使在屏幕上我们看到两段之间是分行的。比如：
			aaa
			bbb
			上面的内容我们看到的是两行，但是实际上vim将aaa，bbb解释成一段，只有两行之间空一行，才认为是两段。如：
			aaa 
		
			bbb
		zc	:z close 折叠起来
		zo	：z open 折行打开，在折行的地方按空格也可以打开折行。
		zr	:减少折叠层次，折叠打开。与zo所不同的是对全文有效，而zo仅仅是对光标所在的折叠处有效。
		zm	:增加折叠层次，折叠起来。是zr的反命令，与zc不同的地方与zr命令一样。
		zR	：全文展开。与zr命令所不同的是，zr每次仅减少一层的折叠层次，如果有比此层更深的层次则不展开，而zR为尽可能的展开更多的层次，即将所有折叠的地方都展开。
		zM	：全文折叠。与zm命令所不同的是，zm每次仅增加一层的折叠层次，此层的上一层并不折叠，而zM则尽可能的折叠更多的层次，即将所有能够折叠的地方都折叠起来，这时可以比较清楚的看到文档的大纲。
		相关命令：
		:set foldmethod[=xx]	设置折叠方法，xx可以是manual，indent，marker，expr。
			manual是手动设置折行标记，用zf命令，在其他方式下zf命令无效。
			indent是根据缩进设置折行标记。自动进行。
			marker是根据文本中的{{{[x]来设置折行标记，x是表示折行深度的数字（1,2,3..).如果不带数字在折行结束的地方需要写上}}}，如果带数字则vim会自动认为前面的折行结束。这种方法的缺点是在文本中需要手动加上折行标记。
			expr是通过编辑的一个表达式来计算折行标记。用:set foldexpr=xxx来设置。比较麻烦，就不写了。
			比较常用的是manual和indent方式。
		:set foldlevel	设置折叠深度。
		set foldlevel=0表示尽可能折叠。zr，zm,zR,zM命令实际上是改变foldlevel数字来实现的。数字越大，表示需要折叠层次越高，即只有达到这个层次的地方才折叠，也就是展开。数字越小，表示需要折叠的层次越低，即只要达到这个层次的地方就折叠，也就是折叠。所以zR命令会在全文查找折叠层次，取最大值作为foldlevel。zM命令将foldlevel设置成0。
	2) 自动折行
		:se foldmethod=index 或marker，expr 
		:se foldlevel=0.可以根据情况来设置。如果在编辑的时候折行乱了，可以用此命令，重新折行。
	3) 折行状态保存
		:mkview(mkvie) x x是需要保存的视图状态数字，可以保存10个视图状态。
		:loadview(lo) x 装入视图。




